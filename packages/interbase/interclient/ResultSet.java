/*
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 */
package interbase.interclient;

/**
 * Represents a cursor for the results of a SQL query.
 *
 * <p>A ResultSet provides access to a table of data.  A ResultSet
 * object is usually generated by executing a Statement.
 *
 * <P>A ResultSet maintains a cursor pointing to its current row of
 * data.  Initially the cursor is positioned before the first row.
 * The 'next' method moves the cursor to the next row.
 *
 * <P>The getXXX methods retrieve column values for the current
 * row.  You can retrieve values either using the index number of the
 * column, or by using the name of the column.  In general using the
 * column index will be more efficient.  Columns are numbered from 1.
 *
 * <P>For maximum portability, ResultSet columns within each row should be
 * read in left-to-right order and each column should be read only once.
 *
 * <P>For the getXXX methods, the JDBC driver attempts to convert the
 * underlying data to the specified Java type and returns a suitable
 * Java value.  See the JDBC specification for allowable mappings
 * from SQL types to Java types with the ResultSet.getXXX methods.
 *
 * <P>Column names used as input to getXXX methods are case
 * insensitive.  When performing a getXXX using a column name, if
 * several columns have the same name, then the value of the first
 * matching column will be returned. The column name option is
 * designed to be used when column names are used in the SQL
 * query. For columns that are NOT explicitly named in the query, it
 * is best to use column numbers. If column names were used there is
 * no way for the programmer to guarantee that they actually refer to
 * the intended columns.
 *
 * <P>A ResultSet is automatically closed by the Statement that
 * generated it when that Statement is closed, re-executed, or is used
 * to retrieve the next result from a sequence of multiple results.
 *
 * <P>The number, types and properties of a ResultSet's columns are
 * provided by the ResulSetMetaData object returned by the getMetaData
 * method.
 *
 * <p><b>InterClient note:</b>
 * As stated in the specification above
 * "ResultSet columns within each row should be
 * read in left-to-right order and each column should be read only once."
 * This reflects implementation limitations in some underlying database
 * protocols.  The current version of InterClient supports random access
 * of result columns.  However, future versions may not have this capability
 * by default in order to leverage any performance advantages that may
 * come with sequential-only access.
 * So in the future, random access may require setting a connection property
 * to enable this behavior.  Please send mail to 
 * <a href="mailto:interclient@interbase.com">mailto:interclient@interbase.com</a> if
 * you have an opinion about this behavior.
 *
 * @see Statement#executeQuery
 * @see Statement#getResultSet
 * @see ResultSetMetaData 
 * @author Paul Ostler
 * @since <font color=red>JDBC 1, with extended behavior in JDBC 2</font>
 **/
final public class ResultSet implements java.sql.ResultSet,
                                        Adaptor,
                                        borland.jdbc.SQLAdapter,
                                        com.inprise.sql.SQLAdapter
{
  int numRows_;

  private RecvMessage recvMsg_;
  private int columnDataPositions_[];

  JDBCNet jdbcNet_;
  private ResultSetMetaData resultSetMetaData_;
  Statement statement_; // seen by friendly result set meta data

  java.util.Hashtable columnNameToIndexCache_ = null;

  private java.sql.SQLWarning sqlWarnings_;

  private boolean isNull_[];

  static final private int WAS_NULL__ = 1;
  static final private int WAS_NOT_NULL__ = 2;
  static final private int WAS_NULL_UNSET__ = 0;

  private int wasNull_ = WAS_NULL_UNSET__;

  // ResultMetaData
  int resultCols_;
  String resultTableNames_[];
  String resultColumnNames_[];  
  String resultColumnLabels_[]; 
  boolean resultNullables_[];   
  int resultTypes_[];           
  int resultPrecisions_[]; // adjusted sqllen
  int resultScales_[];     // sqlscale
  int resultCharSets_[];   
  int resultCharLengths_[];
  // MMM - array of Descriptors
  ArrayDescriptor[] arrayDescriptors_;
  // MMM - end

  char[] cbuf_;

  // Total number of rows read so far.
  // This should never exceed statement_.maxRows_
  private int rowsRead_;

  private boolean openOnClient_ = true;
  boolean openOnServer_;

  String cursorName_ = null;

  boolean validCursorPosition_ = false;

  // Added for Jbuilder performance enhancements
  boolean adaptToRightTrimString_ = false;
  boolean adaptToSingleInstanceTime_ = false;
  IBTimestamp adaptableIBTimestamp_ = null;
  java.sql.Date adaptableDate_ = null;
  java.sql.Time adaptableTime_ = null;
  java.sql.Timestamp adaptableTimestamp_ = null;

  // Called by Connection.prepareStatment() and Statement.execute()
  ResultSet (Statement statement, 
             JDBCNet jdbcNet,
             RecvMessage recvMsg,
             int resultCols, 
             boolean openOnServer)
  {
    resultCols_ = resultCols;

    isNull_ = new boolean [resultCols_];

    resultTableNames_ = new String [resultCols_];
    resultColumnNames_ = new String [resultCols_];
    resultColumnLabels_ = new String [resultCols_];
    resultNullables_ = new boolean [resultCols_];
    resultTypes_ = new int [resultCols_]; 
    resultPrecisions_ = new int [resultCols_];
    resultScales_= new int [resultCols_];
    resultCharSets_ = new int [resultCols_];
    resultCharLengths_ = new int[resultCols_];
    // MMM - create array of ArrayDescriptor
    arrayDescriptors_ = new ArrayDescriptor[resultCols_];
    // MMM - end

    statement_ = statement;
    jdbcNet_ = jdbcNet;
    recvMsg_ = recvMsg;
    rowsRead_ = 0;
    openOnServer_ = openOnServer;
  }

  // Called by DatabaseMetaData Catalog methods to create a "canned" result set.
  // Note: these result sets are special in that they are not associated with a statement.
  // !! Cleanup - remove all references to statement_. in this ResultSet class.
  // !! this way, catalog result sets don't have to have an associated statement.
  ResultSet (Connection connection,
             int statementRef,
             RecvMessage recvMsg,
             JDBCNet jdbcNet,
             int resultCols, 
	     String[] resultColumnNames,
	     boolean[] resultNullables,
	     int[] resultTypes, 
	     int[] resultPrecisions, 
	     int[] resultScales)
  {
    statement_ = new Statement (jdbcNet, connection);
    statement_.statementRef_ = statementRef;
    recvMsg_ = recvMsg;
    resultCols_ = resultCols;
    resultTableNames_ = new String [resultCols_];
    resultColumnNames_ = resultColumnNames;
    resultNullables_ = resultNullables;
    resultTypes_ = resultTypes; 
    resultPrecisions_ = resultPrecisions;
    resultScales_= resultScales;

    // all metadata is currently NONE
    // this will change to Unicode FSS once IB supports SQL Identifiers
    resultCharSets_ = new int[resultCols];
    resultCharLengths_ = resultPrecisions;
    for (int i=0; i<resultCols; i++) {
      resultCharSets_[i] = CharacterEncodings.NONE__;
    }

    allocateCbuf ();

    isNull_ = new boolean [resultCols_];
    jdbcNet_ = jdbcNet;
    rowsRead_ = 0;
    openOnServer_ = true;

    resultColumnLabels_ = resultColumnNames_;

    // Can the result set meta data object
    resultSetMetaData_ = new ResultSetMetaData (this, jdbcNet_);
    resultSetMetaData_.writables_ = new boolean [resultCols_];
    resultSetMetaData_.metaDataRetrieved_ = true;
  }

  // Called when receiving result set meta data from server on prepare,
  // or statement.execute().
  // ResultSets off a prepared statement can be closed and then
  // used again for the statement, so this must be recalled on prepared
  // statement execute if the result set is closed.
  synchronized void allocateCbuf ()
  {
    // get the maximum char length
    int maxCharLength = 0;
    for (int i=0; i<resultCols_; i++) {
      if (resultCharLengths_[i] > maxCharLength)
	maxCharLength = resultCharLengths_[i];
    }
    
    // allocate cbuf to accomodate largest result column
    cbuf_ = Globals.cache__.takeCharBuffer (maxCharLength);
  }

  /**
   * A result set will be closed when its finalizer is called
   * by the garbage collector.  However, there is no guarantee
   * that the garbage collector will ever run, and in general
   * will not run when an application terminates abruptly
   * without closing its resources.
   * <p>
   * Therefore, it is recommended that result sets be
   * explicitly closed even when your application throws an exception.
   * This can be achieved by placing a call to close() in a finally
   * clause of your application as follows
   * <pre>
   * try {
   *   ...
   * }
   * finally {
   *   if (resultSet != null) 
   *     try { resultSet.close (); } catch (SQLException ohWell) {}
   *   if (statement != null)
   *     try { statement.close (); } catch (SQLException ohWell) {}
   *   if (connection != null)
   *     try { connection.close (); } catch (SQLException ohWell) {}
   * }
   * </pre>
   * <p>
   * Or alternatively, use the new System.runFinalizersOnExit(true) method in Java 1.1 or later.
   * @since <font color=red>Extension</font>
   **/
  protected void finalize () throws java.lang.Throwable
  {
    if (openOnServer_)
      close ();

    super.finalize ();
  }

  /**
   * A ResultSet is initially positioned before its first row; the
   * first call to next makes the first row the current row; the
   * second call makes the second row the current row, etc.
   *
   * <P>If an input stream from the previous row is open, it is
   * implicitly closed. The ResultSet's warning chain is cleared
   * when a new row is read.
   *
   * <p><b>InterClient note:</b>
   * InterClient allows for interleaved calls to next() on
   * two separate result sets. 
   *
   * @return true if the new current row is valid; false if there are no more rows
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public boolean next () throws java.sql.SQLException
  {
    checkForClosedCursor ();

    clearWarnings ();

    validCursorPosition_ = getNextCursorPosition ();

    return validCursorPosition_;
  }

  private boolean getNextCursorPosition () throws java.sql.SQLException
  {
    // >>> To handle multiple result sets in the future,
    // >>> we'll need to detect that the "buffer is exhausted"
    // >>> and send FETCH_ROWS for the first next() of the next result set.

    if (recvMsg_ == null) 
      throw new InvalidOperationException (ErrorKey.invalidOperation__read_at_end_of_cursor__);

    if ((statement_.maxRows_ > 0) && (rowsRead_ >= statement_.maxRows_)) {
	    return false;
    }

    try {
      // !!! this currently only accounts for no message streaming
      restoreRowPosition ();  // reset position to beginning of next row
      while (!recvMsg_.get_ROW_DATUM ()) { // no more local rows
	setWarning (recvMsg_.get_WARNINGS ());

	try {
	  if (recvMsg_.getHeaderEndOfStream ()) {
	    openOnServer_ = false; // auto-close result set after last row is read
	    return false;
	  }
	}
	finally {
	  jdbcNet_.destroyRecvMessage (recvMsg_);
	  recvMsg_ = null;
	}
	remote_FETCH_ROWS ();
      }

      // !!! this currently only accounts for no message streaming
      saveBufferedDataPositions (); // read thru row data saving column positions
      saveRowPosition ();  // mark next row position

      rowsRead_++;
      wasNull_ = WAS_NULL_UNSET__;

      return true;
    }
    catch (java.sql.SQLException e) {
      local_Close ();
      jdbcNet_.destroyRecvMessage (recvMsg_);
      recvMsg_ = null;
      throw e;
    }
  }

  void remote_FETCH_ROWS () throws java.sql.SQLException
  {
    recvMsg_ = statement_.remote_recvPrefetch ();

    setNumDataPositions (resultCols_);
    saveRowPosition ();     // mark first row position
    restoreRowPosition ();  // probably a no-op

    // ResultData remains in recvMsg_ buffer 
    // awaiting subsequent ResultSet.next() and get*() calls.

    if (!recvMsg_.getHeaderEndOfStream ())
      statement_.remote_sendPrefetch ();
  }

  // Also used by result set meta data class
  void checkForClosedCursor () throws java.sql.SQLException
  {
    if (!openOnClient_)
      throw new InvalidOperationException (ErrorKey.invalidOperation__result_set_closed__); 
  }

  // ************************************************
  // *** Methods for random access of column data ***
  // ************************************************

  void saveRowPosition () 
  {
    recvMsg_.mark ();
  }

  void restoreRowPosition ()
  {
    recvMsg_.reset ();
  }

  void setNumDataPositions (int cols)
  {
    columnDataPositions_ = new int[cols];
  }

  void saveColumnDataPosition (int columnIndex)
  {
    columnDataPositions_[columnIndex] = recvMsg_.getPosition ();
  }

  private void restoreColumnDataPosition (int columnIndex)
  {
    recvMsg_.setPosition (columnDataPositions_[columnIndex]);
  }

  short getRowData_short (int columnIndex) throws java.sql.SQLException
  {
      restoreColumnDataPosition (columnIndex);
      return recvMsg_.readShort ();
  }

  int getRowData_int (int columnIndex) throws java.sql.SQLException
  {
    restoreColumnDataPosition (columnIndex);
    return recvMsg_.readInt ();
  }

// CJL-IB6 add support for Int 64s
  long getRowData_long (int columnIndex) throws java.sql.SQLException
  {
    restoreColumnDataPosition (columnIndex);
    return recvMsg_.readLong ();
  }
// CJL-IB6 end change

  float getRowData_float (int columnIndex) throws java.sql.SQLException
  {
    restoreColumnDataPosition (columnIndex);
    return recvMsg_.readFloat ();
  }

  double getRowData_double (int columnIndex) throws java.sql.SQLException
  {
    restoreColumnDataPosition (columnIndex);
    return recvMsg_.readDouble ();
  }

  int[] getRowData_timestampId (int columnIndex) throws java.sql.SQLException
  {
    restoreColumnDataPosition (columnIndex);
    return recvMsg_.readTimestampId ();
  }

  int[] getRowData_blobId (int columnIndex) throws java.sql.SQLException
  {
    restoreColumnDataPosition (columnIndex);
    return recvMsg_.readBlobId ();
  }

  // MMM - add getRowData_arrayId()
  int[] getRowData_arrayId (int columnIndex) throws java.sql.SQLException
  {
    restoreColumnDataPosition (columnIndex);
    return recvMsg_.readArrayId ();
  }
  // MMM - end

  // char's are right trimmed by server so we need to pad it back,
  // and *approximately* truncated by maxFieldSize_ on server.
  String getRowData_char (int columnIndex) throws java.sql.SQLException
  {
    restoreColumnDataPosition (columnIndex);
    int nc = recvMsg_.readLDChars (cbuf_, resultCharLengths_[columnIndex]);
    int new_nc = (statement_.maxFieldSize_ == 0) ? nc : Math.min (nc, statement_.maxFieldSize_);
    if (adaptToRightTrimString_)
	while ((new_nc > 0) && (cbuf_[new_nc-1] == 0x20)) { new_nc--; }
    else { // pad
      int padTo = (statement_.maxFieldSize_ == 0) ? resultCharLengths_[columnIndex] : 
	                                            Math.min (resultCharLengths_[columnIndex],
							      statement_.maxFieldSize_);
      while (new_nc < padTo) { cbuf_[new_nc++] = 0x20; }
    }
    return new String (cbuf_, 0, new_nc);
  }

  // varchar's are *not* right trimmed by server, 
  // but are *approximately* truncated by maxFieldSize_ on server.
  String getRowData_varchar (int columnIndex) throws java.sql.SQLException
  {
    restoreColumnDataPosition (columnIndex);
    int nc = recvMsg_.readLDChars (cbuf_, resultCharLengths_[columnIndex]);
    int new_nc = (statement_.maxFieldSize_ == 0) ? nc : Math.min (nc, statement_.maxFieldSize_);
    return new String (cbuf_, 0, new_nc);
  }

  byte[] getRowData_bytes (int columnIndex) throws java.sql.SQLException
  {
    restoreColumnDataPosition (columnIndex);
    return recvMsg_.readLDBytes (statement_.maxFieldSize_);
  }

  void saveBufferedDataPositions () throws java.sql.SQLException
  {
    for (int col = 0; col < resultCols_; col++) {
      isNull_[col] = false;
      if (resultNullables_[col])
        isNull_[col] = recvMsg_.readBoolean ();
      if (!isNull_[col]) {
	saveColumnDataPosition (col);
	switch (resultTypes_[col]) {
	case IBTypes.SMALLINT__: 
	case IBTypes.NUMERIC_SMALLINT__: 
	  recvMsg_.skipShort ();
	  break;
	case IBTypes.INTEGER__: 
	case IBTypes.NUMERIC_INTEGER__:
	  recvMsg_.skipInt ();
	  break;
	case IBTypes.FLOAT__:
	  recvMsg_.skipFloat ();
	  break;
	case IBTypes.DOUBLE__:
	case IBTypes.NUMERIC_DOUBLE__:
	  recvMsg_.skipDouble ();
	  break;
	case IBTypes.CHAR__:
	case IBTypes.VARCHAR__:
          recvMsg_.skipLDBytes ();
	  break;
	case IBTypes.DATE__:
	  recvMsg_.skipTimestampId ();
	  break;
	case IBTypes.CLOB__:
	case IBTypes.BLOB__:
	case IBTypes.ARRAY__:
	  recvMsg_.skipBlobId ();
          break;
// CJL-IB6 support for new types
        case IBTypes.NUMERIC_INT64__:
        case IBTypes.DECIMAL_INT64__:
          recvMsg_.skipLong ();
          break;
        case IBTypes.DECIMAL_INTEGER__:
        case IBTypes.SQLDATE__:
        case IBTypes.TIME__:
          recvMsg_.skipInt ();
	  break;
// CJL-IB6 end change
	}
      }
    }
  }

  // Called by PreparedStatement execute methods.
  void setRecvBuffer (RecvMessage recvMsg)
  {
    recvMsg_ = recvMsg;
    setNumDataPositions (resultCols_);
    saveRowPosition ();
  }

  // Called by prepared statements to reopen a closed result set.
  // !! change name to reopen ()
  void local_open ()
  {
    openOnServer_ = true;
    openOnClient_ = true;
    rowsRead_ = 0;

    // The result set may have been previously closed,
    // this restores any reclaimed restructures so the result set
    // may be reused.
    if (cbuf_ == null)
      allocateCbuf ();
  }

  // Called by Connection.close() to mark open result sets as closed.
  // Always called by commit() and rollback().
  // Called by Statement.close()
  void local_Close () throws java.sql.SQLException
  {
    openOnServer_ = false;
    openOnClient_ = false;
    jdbcNet_.destroyRecvMessage (recvMsg_);
    recvMsg_ = null;
    // Result sets off a prepared statement can be reused after closed,
    // so this buffer must be reconstituted on next prepared statement execute.
    Globals.cache__.returnCharBuffer (cbuf_);
    cbuf_ = null;
  }

  /**
   * In some cases, it is desirable to immediately release a
   * ResultSet's database and JDBC resources instead of waiting for
   * this to happen when it is automatically closed; the close
   * method provides this immediate release.
   *
   * <P><B>Note:</B> A ResultSet is automatically closed by the
   * Statement that generated it when that Statement is closed,
   * re-executed, or is used to retrieve the next result from a
   * sequence of multiple results. A ResultSet is also automatically
   * closed when it is garbage collected.
   *
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public void close () throws java.sql.SQLException
  {  
    jdbcNet_.destroyRecvMessage (recvMsg_);
    recvMsg_ = null;

    if (openOnServer_) {
      remote_CLOSE_CURSOR ();
    }

    local_Close ();
  }

  synchronized void remote_CLOSE_CURSOR () throws java.sql.SQLException
  {
    // !! To handle multiple result sets in the future,
    // !! we'll need to skip thru the buffer to the next set of result data or update count

    // !!! does prefetched message get flushed out automatically?

    MessageBufferOutputStream sendMsg = jdbcNet_.createMessage ();
    sendMsg.writeByte (MessageCodes.CLOSE_CURSOR__);
    sendMsg.writeInt (statement_.statementRef_);

    RecvMessage recvMsg = null;
    try {
      recvMsg = jdbcNet_.sendAndReceiveMessage (sendMsg);

      if (!recvMsg.get_SUCCESS ()) {
	throw recvMsg.get_EXCEPTIONS ();
      }

      setWarning (recvMsg.get_WARNINGS ());
    }
    finally {
      jdbcNet_.destroyRecvMessage (recvMsg);
    }
  }

  void checkForValidCursorPosition () throws java.sql.SQLException
  {
    if (!validCursorPosition_)
      throw new InvalidOperationException (ErrorKey.invalidOperation__read_at_invalid_cursor_position__);
  }

  /**
   * A column may have the value of SQL NULL; wasNull reports whether
   * the last column read had this special value.
   * Note that you must first call getXXX on a column to try to read
   * its value and then call wasNull() to find if the value was
   * the SQL NULL.
   *
   * @return true if last column read was SQL NULL
   * @throws java.sql.SQLException if a database access error occurs.
   * @see #isNull
   * @since <font color=red>JDBC 1</font>
   **/
  public boolean wasNull () throws java.sql.SQLException
  {
    checkForClosedCursor ();

    if (wasNull_ == WAS_NULL_UNSET__)
      throw new InvalidOperationException (ErrorKey.invalidOperation__was_null_with_no_data_retrieved__);

    return wasNull_ == WAS_NULL__;
  }

  //======================================================================
  // Methods for accessing results by column index
  //======================================================================

  /**
   * Get the value of a column in the current row as a Java String.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public String getString (int column) throws java.sql.SQLException
  {
    if (isNullPreamble (column))
      return null;

    switch (resultTypes_[column-1]) {
    case IBTypes.CHAR__:
      return getRowData_char (column-1);

    case IBTypes.VARCHAR__:
      return getRowData_varchar (column-1);

    // !!! getString() must work on all types
    // MMM - does not work for arrays
    case IBTypes.ARRAY__:
      //throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__);
      return "";
    // MMM - end

    case IBTypes.CLOB__:
    case IBTypes.BLOB__:
      int[] blobId = getRowData_blobId (column-1);
      return jdbcNet_.openBlobOutput (statement_, blobId).getString ();

    case IBTypes.SMALLINT__:
      return String.valueOf (getRowData_short (column-1));

    case IBTypes.INTEGER__:
      return String.valueOf (getRowData_int (column-1));

    case IBTypes.FLOAT__:
      return String.valueOf (getRowData_float (column-1));

    case IBTypes.DOUBLE__:
      return String.valueOf (getRowData_double (column-1));

    case IBTypes.NUMERIC_SMALLINT__:
    case IBTypes.NUMERIC_INTEGER__:
    case IBTypes.NUMERIC_DOUBLE__:
      return getBigDecimal (column, resultScales_[column-1]).toString ();

    case IBTypes.DATE__:
      return getTimestamp (column).toString ();

// CJL-IB6 support of new types
    case IBTypes.SQLDATE__:
      return getDate (column).toString ();

    case IBTypes.TIME__:
      return getTime (column).toString ();

    case IBTypes.NUMERIC_INT64__:
    case IBTypes.DECIMAL_INT64__:
    case IBTypes.DECIMAL_INTEGER__:
      return getBigDecimal (column, resultScales_[column-1]).toString ();

// CJL-IB6 end change
    default:
      throw new BugCheckException (ErrorKey.bugCheck__0__, 114);
    }
  }

  /**
   * Get the value of a column in the current row as a Java boolean.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is false
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public boolean getBoolean (int column) throws java.sql.SQLException
  {
    return (getInt (column) != 0);
  }

  /**
   * Get the value of a column in the current row as a Java byte.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is 0
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public byte getByte (int column) throws java.sql.SQLException
  {
    return (byte) getInt (column);
  }

  /**
   * Get the value of a column in the current row as a Java short.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is 0
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public short getShort (int column) throws java.sql.SQLException
  {
    return (short) getInt (column);
  }

  /**
   * Get the value of a column in the current row as a Java int.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is 0
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public int getInt (int column) throws java.sql.SQLException
  {
    if (isNullPreamble (column))
      return 0;

    switch (resultTypes_[column-1]) {
    case IBTypes.SMALLINT__:
      return (int) getRowData_short (column-1);
    case IBTypes.INTEGER__:
      return getRowData_int (column-1);

    case IBTypes.NUMERIC_INTEGER__: 
      return java.math.BigDecimal.valueOf ((long) getRowData_int (column-1),
				           resultScales_[column-1]).intValue ();
    case IBTypes.NUMERIC_SMALLINT__:
      return java.math.BigDecimal.valueOf ((long) getRowData_short (column-1),
				           resultScales_[column-1]).intValue ();

    case IBTypes.NUMERIC_DOUBLE__:
    case IBTypes.DOUBLE__:
      return (int) getRowData_double (column-1);

// CJL-IB6 support for new fixed numeric types
    case IBTypes.DECIMAL_INTEGER__:
      return java.math.BigDecimal.valueOf ((long) getRowData_int (column-1),
				           resultScales_[column-1]).intValue ();
    case IBTypes.NUMERIC_INT64__:
    case IBTypes.DECIMAL_INT64__:
      return java.math.BigDecimal.valueOf ( getRowData_long (column-1),
				           resultScales_[column-1]).intValue ();
// CJL-IB6 end change

    case IBTypes.FLOAT__:
      return (int) getRowData_float (column-1);

    case IBTypes.CHAR__:
    case IBTypes.VARCHAR__:
    case IBTypes.CLOB__:
      String strRep = getString (column);
      try {
        return Integer.parseInt (strRep);
      }
      catch (NumberFormatException e) {
        throw new ColumnConversionException (ErrorKey.columnConversion__instance_conversion_0__,
					     strRep);
      }

    case IBTypes.BLOB__:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__get_number_on_binary_blob__);

    default:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__);
    }
  }

  /**
   * Get the value of a column in the current row as a Java long.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is 0
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public long getLong (int column) throws java.sql.SQLException
  {
    if (isNullPreamble (column))
      return 0;

    switch (resultTypes_[column-1]) {
    case IBTypes.NUMERIC_DOUBLE__: // scale should be maintained by IB. 
    case IBTypes.DOUBLE__:
      return (long) getRowData_double (column-1);

    case IBTypes.SMALLINT__:
      return (long) getRowData_short (column-1);
    case IBTypes.INTEGER__:
      return (long) getRowData_int (column-1);

    case IBTypes.NUMERIC_INTEGER__: 
      return java.math.BigDecimal.valueOf ((long) getRowData_int (column-1),
				           resultScales_[column-1]).longValue ();
    case IBTypes.NUMERIC_SMALLINT__: 
      return java.math.BigDecimal.valueOf ((long) getRowData_short (column-1),
				           resultScales_[column-1]).longValue ();

// CJL-IB6 support for new fixed numeric types
    case IBTypes.DECIMAL_INTEGER__:
      return java.math.BigDecimal.valueOf ((long) getRowData_int (column-1),
				           resultScales_[column-1]).longValue ();
    case IBTypes.NUMERIC_INT64__:
    case IBTypes.DECIMAL_INT64__:
      return java.math.BigDecimal.valueOf ( getRowData_long (column-1),
				           resultScales_[column-1]).longValue ();
// CJL-IB6 end change

    case IBTypes.FLOAT__:
      return (long) getRowData_float (column-1);

    case IBTypes.CHAR__:
    case IBTypes.VARCHAR__:
    case IBTypes.CLOB__:
      String strRep = getString (column);
      try {
        return Long.parseLong (strRep);
      }
      catch (NumberFormatException e) {
        throw new ColumnConversionException (ErrorKey.columnConversion__instance_conversion_0__,
					     strRep);
      }

    case IBTypes.BLOB__:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__get_number_on_binary_blob__);

    default:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__);
    }
  }

  /**
   * Get the value of a column in the current row as a Java float.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is 0
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public float getFloat (int column) throws java.sql.SQLException
  {
    if (isNullPreamble (column))
      return 0;

    switch (resultTypes_[column-1]) {
    case IBTypes.FLOAT__:
      return getRowData_float (column-1);

    case IBTypes.NUMERIC_DOUBLE__: // scale should be maintained by IB.
    case IBTypes.DOUBLE__:
      return (float) getRowData_double (column-1);

    case IBTypes.INTEGER__:
      return (float) getRowData_int (column-1);
    case IBTypes.SMALLINT__:
      return (float) getRowData_short (column-1);

    case IBTypes.NUMERIC_INTEGER__:
      return java.math.BigDecimal.valueOf ((long) getRowData_int (column-1),
				           resultScales_[column-1]).floatValue ();
    case IBTypes.NUMERIC_SMALLINT__:
      return java.math.BigDecimal.valueOf ((long) getRowData_short (column-1),
				           resultScales_[column-1]).floatValue ();

// CJL-IB6 support for new fixed numeric types
    case IBTypes.DECIMAL_INTEGER__:
      return java.math.BigDecimal.valueOf ((long) getRowData_int (column-1),
				           resultScales_[column-1]).floatValue ();
    case IBTypes.NUMERIC_INT64__:
    case IBTypes.DECIMAL_INT64__:
      return java.math.BigDecimal.valueOf ( getRowData_long (column-1),
				           resultScales_[column-1]).floatValue ();
// CJL-IB6 end change

    case IBTypes.CHAR__:
    case IBTypes.VARCHAR__:
    case IBTypes.CLOB__:
      String strRep = getString (column);
      try {
        return Float.valueOf (strRep).floatValue ();
      }
      catch (java.lang.NumberFormatException e) {
        throw new ColumnConversionException (ErrorKey.columnConversion__instance_conversion_0__,
					     strRep);
      }

    case IBTypes.BLOB__:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__get_number_on_binary_blob__);

    default:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__);
    }
  }

  /**
   * Get the value of a column in the current row as a Java double.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is 0
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public double getDouble (int column) throws java.sql.SQLException
  {
    if (isNullPreamble (column))
      return 0;

    switch (resultTypes_[column-1]) {
    case IBTypes.NUMERIC_DOUBLE__: // scale is maintained by IB.
    case IBTypes.DOUBLE__:
      return getRowData_double (column-1);
    
    case IBTypes.SMALLINT__:
      return (double) getRowData_short (column-1);
    case IBTypes.INTEGER__:
      return (double) getRowData_int (column-1);

    case IBTypes.NUMERIC_INTEGER__: 
      return java.math.BigDecimal.valueOf ((long) getRowData_int (column-1),
				           resultScales_[column-1]).doubleValue ();
    case IBTypes.NUMERIC_SMALLINT__: 
      return java.math.BigDecimal.valueOf ((long) getRowData_short (column-1),
				           resultScales_[column-1]).doubleValue ();

// CJL-IB6 support for new fixed numeric types
    case IBTypes.DECIMAL_INTEGER__:
      return java.math.BigDecimal.valueOf ((long) getRowData_int (column-1),
				           resultScales_[column-1]).doubleValue ();
    case IBTypes.NUMERIC_INT64__:
    case IBTypes.DECIMAL_INT64__:
      return java.math.BigDecimal.valueOf ( getRowData_long (column-1),
				           resultScales_[column-1]).doubleValue ();
// CJL-IB6 end change

    case IBTypes.FLOAT__:
      return (double) getRowData_float (column-1);

    case IBTypes.CHAR__:
    case IBTypes.VARCHAR__:
    case IBTypes.CLOB__:
      String strRep = getString (column);
      try {
        return Double.valueOf (strRep).doubleValue ();
      }
      catch (NumberFormatException e) {
        throw new ColumnConversionException (ErrorKey.columnConversion__instance_conversion_0__,
					     strRep);
      }

    case IBTypes.BLOB__:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__get_number_on_binary_blob__);

    default:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__);
    }
  }

  /**
   * Get the value of a column in the current row as a java.math.BigDecimal object.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param scale the number of digits to the right of the decimal
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs.
   * @deprecated To be deprecated in InterClient 2, replaced by
   * {@link #getBigDecimal(int) getBigDecimal(column)} without scale in JDBC 2
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public java.math.BigDecimal getBigDecimal (int column, int scale) throws java.sql.SQLException
  {
    if (isNullPreamble (column))
      return null;

    java.math.BigDecimal result = null;
    switch (resultTypes_[column-1]) {
    case IBTypes.SMALLINT__:
      return java.math.BigDecimal.valueOf ((long) getRowData_short (column-1), scale);
    case IBTypes.INTEGER__:
      return java.math.BigDecimal.valueOf ((long) getRowData_int (column-1), scale);

    case IBTypes.NUMERIC_INTEGER__:
      return java.math.BigDecimal.valueOf ((long) getRowData_int (column-1),
				           resultScales_[column-1]).setScale (scale,
								              java.math.BigDecimal.ROUND_HALF_EVEN);
    case IBTypes.NUMERIC_SMALLINT__:
      return java.math.BigDecimal.valueOf ((long) getRowData_short (column-1),
				           resultScales_[column-1]).setScale (scale,
								              java.math.BigDecimal.ROUND_HALF_EVEN);

    case IBTypes.DOUBLE__:
    case IBTypes.NUMERIC_DOUBLE__:
      return (new java.math.BigDecimal (getRowData_double (column-1))).setScale (scale,
                                                                                 java.math.BigDecimal.ROUND_HALF_EVEN);

    case IBTypes.FLOAT__:
      return (new java.math.BigDecimal ((double) getRowData_float (column-1))).setScale (scale,
                                                                                         java.math.BigDecimal.ROUND_HALF_EVEN);

// CJL-IB6 support for new types
    case IBTypes.DECIMAL_INTEGER__:
      return java.math.BigDecimal.valueOf ((long) getRowData_int (column-1),
				           resultScales_[column-1]).setScale (scale,
								              java.math.BigDecimal.ROUND_HALF_EVEN);
    case IBTypes.NUMERIC_INT64__:
    case IBTypes.DECIMAL_INT64__:
      return java.math.BigDecimal.valueOf ( getRowData_long (column-1),
				           resultScales_[column-1]).setScale (scale,
								              java.math.BigDecimal.ROUND_HALF_EVEN);
// CJL-IB6 end change
    case IBTypes.CHAR__:
    case IBTypes.VARCHAR__:
    case IBTypes.CLOB__:
      String strRep = getString (column);
      try {
	return (new java.math.BigDecimal (strRep).setScale (scale,
						            java.math.BigDecimal.ROUND_HALF_EVEN));
      }
      catch (NumberFormatException e) {
        throw new ColumnConversionException (ErrorKey.columnConversion__instance_conversion_0__,
					     strRep);
      }

    case IBTypes.BLOB__:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__get_number_on_binary_blob__);

    default:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__);
    }
  }

  /**
   * Get the value of a column in the current row as a Java byte array.
   * The bytes represent the raw values returned by the driver.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public byte[] getBytes (int column) throws java.sql.SQLException
  { 
    if (isNullPreamble (column))
      return null;

    switch (resultTypes_[column-1]) {
    case IBTypes.CLOB__: 
    case IBTypes.BLOB__:
      // MMM - does not works for array parameters
      // case IBTypes.ARRAY__:
      // MMM - end
      int blobId[] = getRowData_blobId (column-1);
      return jdbcNet_.openBlobOutput (statement_, blobId).getBytes (); // !!! check this out.

    case IBTypes.CHAR__:
    case IBTypes.VARCHAR__:
      return getRowData_bytes (column-1);

    default:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__);
    }
  }

  /**
   * Get the value of a column in the current row as a java.sql.Date object.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public java.sql.Date getDate (int column) throws java.sql.SQLException
  {

    if (isNullPreamble (column))
      return null;

    switch (resultTypes_[column-1]) {
    case IBTypes.DATE__: {
      // !!! any way to get this in a long rather than int[]
      int timestampId[] = getRowData_timestampId (column-1);
      //Torsten-start 08-11-2000
      IBTimestamp ibTimestamp = new IBTimestamp (IBTimestamp.DATE, timestampId);
      if (adaptToSingleInstanceTime_) {
        adaptableDate_.setTime(ibTimestamp.getTimeInMillis());
        return adaptableDate_;
      } else {
        return new java.sql.Date(ibTimestamp.getTimeInMillis());
      }
      //Torsten-end 08-11-2000
    }
// CJL-IB6 support for new types
    case IBTypes.SQLDATE__: {
      int encodedDate = getRowData_int (column-1);

      //ODonohue -start 01-Feb-2001

      IBTimestamp ibTimestamp = new IBTimestamp (IBTimestamp.DATE, encodedDate);
      if (adaptToSingleInstanceTime_) {
        adaptableDate_.setTime(ibTimestamp.getTimeInMillis());
        return adaptableDate_;
      } else {
        return new java.sql.Date(ibTimestamp.getTimeInMillis());
      }
    }
      //ODonohue - end 01-Feb-2001

// CJL-IB6 end change
    case IBTypes.CHAR__:
    case IBTypes.VARCHAR__:
    case IBTypes.CLOB__:
      String strRep = getString (column);
      try {
        return java.sql.Date.valueOf (strRep);
      }
      catch (java.lang.IllegalArgumentException e) {
        throw new ColumnConversionException (ErrorKey.columnConversion__instance_conversion_0__,
					     strRep);
      }

    case IBTypes.BLOB__:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__get_date_on_binary_blob__);

    default:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__);
    }
  }

  /**
   * Get the value of a column in the current row as a java.sql.Time object.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public java.sql.Time getTime (int column) throws java.sql.SQLException
  {
    if (isNullPreamble (column))
      return null;

    switch (resultTypes_[column-1]) {
    case IBTypes.DATE__:
      int timestampId[] = getRowData_timestampId (column-1);
      if (adaptToSingleInstanceTime_) {
        adaptableIBTimestamp_.setTimestampId (IBTimestamp.TIME, timestampId);
        adaptableTime_.setTime(adaptableIBTimestamp_.getTimeInMillis());
        return adaptableTime_;
      } else {
        IBTimestamp ibTimestamp = new IBTimestamp (IBTimestamp.TIME, timestampId);
        return new java.sql.Time(ibTimestamp.getTimeInMillis());
      }
      //old code-start
      /*
      if (adaptToSingleInstanceTime_) {
        adaptableIBTimestamp_.setTimestampId (IBTimestamp.TIME, timestampId);
        adaptableTime_.setHours (adaptableIBTimestamp_.getHours ());
        adaptableTime_.setMinutes (adaptableIBTimestamp_.getMinutes ());
        adaptableTime_.setSeconds (adaptableIBTimestamp_.getSeconds ());
        return adaptableTime_;
      }
      else {
	IBTimestamp ibTimestamp = new IBTimestamp (IBTimestamp.TIME, timestampId);
	return (new java.sql.Time (ibTimestamp.getHours (),
			  ibTimestamp.getMinutes (),
			  ibTimestamp.getSeconds ()));
      }
      */
      //old code-end
      //Torsten-end 08-11-2000

// CJL-IB6 add support for new types (
    case IBTypes.TIME__:
      int encodedTime = getRowData_int (column-1);
      if (adaptToSingleInstanceTime_) {
        adaptableIBTimestamp_.setDateTime( IBTimestamp.TIME, encodedTime );
        adaptableTime_.setHours (adaptableIBTimestamp_.getHours ());
        adaptableTime_.setMinutes (adaptableIBTimestamp_.getMinutes ());
        adaptableTime_.setSeconds (adaptableIBTimestamp_.getSeconds ());
        return adaptableTime_;
      }
      else {
        IBTimestamp ibTimestamp = new IBTimestamp (IBTimestamp.TIME, encodedTime);
	return (new java.sql.Time (ibTimestamp.getHours (),
			  ibTimestamp.getMinutes (),
			  ibTimestamp.getSeconds ()));
      }
// CJL-IB6 end change

    case IBTypes.CHAR__:
    case IBTypes.VARCHAR__:
    case IBTypes.CLOB__:
      String strRep = getString (column);
      try {
        return java.sql.Time.valueOf (strRep);
      }
      catch (java.lang.IllegalArgumentException e) {
        throw new ColumnConversionException (ErrorKey.columnConversion__instance_conversion_0__,
					     strRep);
      }

    case IBTypes.BLOB__:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__get_date_on_binary_blob__);

    default:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__);
    }
  }

  /**
   * Get the value of a column in the current row as a java.sql.Timestamp object.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public java.sql.Timestamp getTimestamp (int column) throws java.sql.SQLException
  {
    if (isNullPreamble (column))
      return null;

    switch (resultTypes_[column-1]) {
    case IBTypes.DATE__: {
      int timestampId[] = getRowData_timestampId (column-1);
      //Torsten-start 08-11-2000
      if (adaptToSingleInstanceTime_) {
        adaptableIBTimestamp_.setTimestampId (IBTimestamp.DATETIME, timestampId);
        adaptableTimestamp_.setTime(adaptableIBTimestamp_.getTimeInMillis());
        adaptableTimestamp_.setNanos(adaptableIBTimestamp_.getNanos());
        return adaptableTimestamp_;
      } else {
        IBTimestamp ibTimestamp = new IBTimestamp (IBTimestamp.DATETIME,timestampId);
        java.sql.Timestamp result = new java.sql.Timestamp(ibTimestamp.getTimeInMillis());
        result.setNanos(ibTimestamp.getNanos());
        return result;
      }
      //Torsten-end 08-11-2000
    }

// CJL-IB6 add support for new types
    // fills timestamp with dummy time (12:00:00.00000000 a.m.)
    case IBTypes.SQLDATE__:
      int encodedDate = getRowData_int (column-1);
      if (adaptToSingleInstanceTime_) {
        adaptableIBTimestamp_.setDateTime (IBTimestamp.DATE, encodedDate);
        adaptableTimestamp_.setYear (adaptableIBTimestamp_.getYear ());
        adaptableTimestamp_.setMonth (adaptableIBTimestamp_.getMonth ());
        adaptableTimestamp_.setDate (adaptableIBTimestamp_.getDate ());
        adaptableTimestamp_.setHours (0);
        adaptableTimestamp_.setMinutes (0);
        adaptableTimestamp_.setSeconds (0);
        adaptableTimestamp_.setNanos (0);
        return adaptableTimestamp_;
      }
      else {
	IBTimestamp ibTimestamp = new IBTimestamp (IBTimestamp.DATE,
						   encodedDate);
	return (new java.sql.Timestamp (ibTimestamp.getYear (),
			       ibTimestamp.getMonth (),
			       ibTimestamp.getDate (),
			       0,
			       0,
			       0,
			       0 ) );
      }
        
    // fills timestamp with dummy date (1/1/1900)
    case IBTypes.TIME__:
      int encodedTime = getRowData_int (column-1);
      if (adaptToSingleInstanceTime_) {
        adaptableIBTimestamp_.setDateTime (IBTimestamp.TIME, encodedTime);
        adaptableTimestamp_.setYear (0);
        adaptableTimestamp_.setMonth (0);
        adaptableTimestamp_.setDate (1);
        adaptableTimestamp_.setHours (adaptableIBTimestamp_.getHours ());
        adaptableTimestamp_.setMinutes (adaptableIBTimestamp_.getMinutes ());
        adaptableTimestamp_.setSeconds (adaptableIBTimestamp_.getSeconds ());
        adaptableTimestamp_.setNanos (adaptableIBTimestamp_.getNanos ());
        return adaptableTimestamp_;
      }
      else {
	IBTimestamp ibTimestamp = new IBTimestamp (IBTimestamp.TIME,
						   encodedTime);
	return (new java.sql.Timestamp (0,  // 1900
			       0,           // JAN
			       1,           // 1st
			       ibTimestamp.getHours (),
			       ibTimestamp.getMinutes (),
			       ibTimestamp.getSeconds (),
			       ibTimestamp.getNanos ()));
      }
// CJL-IB6 end change
    case IBTypes.CHAR__:
    case IBTypes.VARCHAR__:
    case IBTypes.CLOB__:
      String strRep = getString (column);
      try {
        return java.sql.Timestamp.valueOf (strRep);
      }
      catch (java.lang.IllegalArgumentException e) {
        throw new ColumnConversionException (ErrorKey.columnConversion__instance_conversion_0__,
					     strRep);
      }

    case IBTypes.BLOB__:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__get_date_on_binary_blob__);

    default:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__);
    }
  }

  /**
   * A column value can be retrieved as a stream of ASCII characters
   * and then read in chunks from the stream.  This method is particularly
   * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
   * do any necessary conversion from the database format into ASCII.
   *
   * <P><B>Note:</B> All the data in the returned stream must be
   * read prior to getting the value of any other column. The next
   * call to a get method implicitly closes the stream. . Also, a
   * stream may return 0 for available() whether there is data
   * available or not.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return a Java input stream that delivers the database column value
   *   as a stream of one byte ASCII characters.  If the value is SQL NULL
   *   then the result is null.
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public java.io.InputStream getAsciiStream (int column) throws java.sql.SQLException
  {
    if (isNullPreamble (column))
      return null;

    switch (resultTypes_[column-1]) {
    case IBTypes.CLOB__: 
    case IBTypes.BLOB__:
      // MMM - does not works for array parameters
      // case IBTypes.ARRAY__:
      // MMM - end
      int blobId[] = getRowData_blobId (column-1);
      return jdbcNet_.openBlobOutput (statement_, blobId).getInputStream ();

    case IBTypes.CHAR__:
    case IBTypes.VARCHAR__:
      return new java.io.ByteArrayInputStream (getRowData_bytes (column-1));

    default:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__);
    }
  }

  /**
   * A column value can be retrieved as a stream of Unicode characters
   * and then read in chunks from the stream.  This method is particularly
   * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
   * do any necessary conversion from the database format into Unicode.
   *
   * <P><B>Note:</B> All the data in the returned stream must be
   * read prior to getting the value of any other column. The next
   * call to a get method implicitly closes the stream. . Also, a
   * stream may return 0 for available() whether there is data
   * available or not.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return a Java input stream that delivers the database column value
   * as a stream of two byte Unicode characters.  If the value is SQL NULL
   * then the result is null.
   * @throws java.sql.SQLException if a database access error occurs.
   * @deprecated To be deprecated in InterClient 2, replaced by
   * {@link #getCharacterStream(int) getCharacterStream(column)} in JDBC 2.
   * @see #getCharacterStream
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public java.io.InputStream getUnicodeStream (int column) throws java.sql.SQLException
  {
    if (isNullPreamble (column))
      return null;

    switch (resultTypes_[column-1]) {
    case IBTypes.CLOB__:
    case IBTypes.BLOB__: 
      // MMM - does not works for array parameters
      // case IBTypes.ARRAY__:
      // MMM - end
      int blobId[] = getRowData_blobId (column-1);
      return jdbcNet_.openBlobOutput (statement_, blobId).getUnicodeInputStream ();

    case IBTypes.CHAR__:
      return new ByteToUnicodeConverterStream (getRowData_char (column-1));

    case IBTypes.VARCHAR__:
      return new ByteToUnicodeConverterStream (getRowData_varchar (column-1));

    default:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__);
    }
  }

  /**
   * A column value can be retrieved as a stream of uninterpreted bytes
   * and then read in chunks from the stream.  This method is particularly
   * suitable for retrieving large LONGVARBINARY values.
   *
   * <P><B>Note:</B> All the data in the returned stream must be
   * read prior to getting the value of any other column. The next
   * call to a get method implicitly closes the stream. Also, a
   * stream may return 0 for available() whether there is data
   * available or not.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return a Java input stream that delivers the database column value
   *   as a stream of uninterpreted bytes.  If the value is SQL NULL
   *   then the result is null.
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public java.io.InputStream getBinaryStream (int column) throws java.sql.SQLException
  {
    if (isNullPreamble (column))
      return null;

    switch (resultTypes_[column-1]) {
    case IBTypes.CLOB__: 
    case IBTypes.BLOB__:
      // MMM - does not works for array parameters
      // case IBTypes.ARRAY__:
      // MMM - end
      int blobId[] = getRowData_blobId (column-1);
      return jdbcNet_.openBlobOutput (statement_, blobId).getInputStream ();

    case IBTypes.CHAR__:
    case IBTypes.VARCHAR__:
      return new java.io.ByteArrayInputStream (getRowData_bytes (column-1));

    default:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__);
    }
  }

    //======================================================================
    // Methods for accessing results by column name
    //======================================================================

  /**
   * Get the value of a column in the current row as a Java String.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public String getString (String columnName) throws java.sql.SQLException
  {
    return getString (findColumn (columnName));
  }

  /**
   * Get the value of a column in the current row as a Java boolean.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is false
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public boolean getBoolean (String columnName) throws java.sql.SQLException
  {
    return getBoolean (findColumn (columnName));
  }  

  /**
   * Get the value of a column in the current row as a Java byte.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is 0
   * @throws java.sql.SQLException if a database access error occurs.
   **/
  synchronized public byte getByte (String columnName) throws java.sql.SQLException
  {
    return getByte (findColumn (columnName));
  }  

  /**
   * Get the value of a column in the current row as a Java short.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is 0
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public short getShort (String columnName) throws java.sql.SQLException
  {
    return getShort (findColumn (columnName));
  }  

  /**
   * Get the value of a column in the current row as a Java int.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is 0
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public int getInt (String columnName) throws java.sql.SQLException
  {
    return getInt (findColumn (columnName));
  }  

  /**
   * Get the value of a column in the current row as a Java long.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is 0
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public long getLong (String columnName) throws java.sql.SQLException
  {
    return getLong (findColumn (columnName));
  }  

  /**
   * Get the value of a column in the current row as a Java float.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is 0
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public float getFloat (String columnName) throws java.sql.SQLException
  {
    return getFloat (findColumn (columnName));
  }  

  /**
   * Get the value of a column in the current row as a Java double.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is 0
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public double getDouble (String columnName) throws java.sql.SQLException
  {
    return getDouble (findColumn (columnName));
  }  

  /**
   * Get the value of a column in the current row as a java.math.BigDecimal object.
   *
   * @param columnName is the SQL name of the column
   * @param scale the number of digits to the right of the decimal
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs.
   * @deprecated To be deprecated in InterClient 2, replaced by
   * {@link #getBigDecimal(String) getBigDecimal(columnName)} without scale in JDBC 2
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public java.math.BigDecimal getBigDecimal (String columnName, int scale) throws java.sql.SQLException
  {
    return getBigDecimal (findColumn (columnName), scale);
  }

  /**
   * Get the value of a column in the current row as a Java byte array.
   * The bytes represent the raw values returned by the driver.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public byte[] getBytes (String columnName) throws java.sql.SQLException
  {
    return getBytes (findColumn (columnName));
  }  

  /**
   * Get the value of a column in the current row as a java.sql.Date object.
   *
   * <p><b>InterClient note:</b>
   * In order to improve performance when scrolling
   * through a result set, this method can be used
   * in conjunction with interbase.interclient.Adaptor.SINGLE_INSTANCE_TIME
   * so that only a single Date instance is created for
   * any given result set; the single Date instance is reused row by row.
   * This saves the overhead in calling the Date constructor for each row.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public java.sql.Date getDate (String columnName) throws java.sql.SQLException
  {
    return getDate (findColumn (columnName));
  }  

  /**
   * Get the value of a column in the current row as a java.sql.Time object.
   *
   * <p><b>InterClient note:</b>
   * In order to improve performance when scrolling
   * through a result set, this method can be used
   * in conjunction with interbase.interclient.Adaptor.SINGLE_INSTANCE_TIME
   * so that only a single Time instance is created for
   * any given result set; the single Time instance is reused row by row.
   * This saves the overhead in calling the Time constructor for each row.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public java.sql.Time getTime (String columnName) throws java.sql.SQLException
  {
    return getTime (findColumn (columnName));
  }

  /**
   * Get the value of a column in the current row as a java.sql.Timestamp object.
   *
   * <p><b>InterClient note:</b>
   * In order to improve performance when scrolling
   * through a result set, this method can be used
   * in conjunction with interbase.interclient.Adaptor.SINGLE_INSTANCE_TIME
   * so that only a single Timestamp instance is created for
   * any given result set; the single Timestamp instance is reused row by row.
   * This saves the overhead in calling the Timestamp constructor for each row.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public java.sql.Timestamp getTimestamp (String columnName) throws java.sql.SQLException
  {
    return getTimestamp (findColumn (columnName));
  }  

  /**
   * A column value can be retrieved as a stream of ASCII characters
   * and then read in chunks from the stream.  This method is particularly
   * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
   * do any necessary conversion from the database format into ASCII.
   *
   * <P><B>Note:</B> All the data in the returned stream must
   * be read prior to getting the value of any other column. The
   * next call to a get method implicitly closes the stream.
   *
   * @param columnName is the SQL name of the column
   * @return a Java input stream that delivers the database column value
   *   as a stream of one byte ASCII characters.  If the value is SQL NULL
   *   then the result is null.
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public java.io.InputStream getAsciiStream (String columnName) throws java.sql.SQLException
  {
    return getAsciiStream (findColumn (columnName));
  }  

  /**
   * A column value can be retrieved as a stream of Unicode characters
   * and then read in chunks from the stream.  This method is particularly
   * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
   * do any necessary conversion from the database format into Unicode.
   *
   * <P><B>Note:</B> All the data in the returned stream must
   * be read prior to getting the value of any other column. The
   * next call to a get method implicitly closes the stream.
   *
   * @param columnName is the SQL name of the column
   * @return a Java input stream that delivers the database column value
   *   as a stream of two byte Unicode characters.  If the value is SQL NULL
   *   then the result is null.
   * @throws java.sql.SQLException if a database access error occurs.
   * @deprecated To be deprecated in InterClient 2, replaced by
   * {@link #getCharacterStream(String) getCharacterStream(columnName)} in JDBC 2.
   * @see #getCharacterStream
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public java.io.InputStream getUnicodeStream (String columnName) throws java.sql.SQLException
  {
    return getUnicodeStream (findColumn (columnName));
  }  

  /**
   * A column value can be retrieved as a stream of uninterpreted bytes
   * and then read in chunks from the stream.  This method is particularly
   * suitable for retrieving large LONGVARBINARY values.
   *
   * <P><B>Note:</B> All the data in the returned stream must
   * be read prior to getting the value of any other column. The
   * next call to a get method implicitly closes the stream.
   *
   * @param columnName is the SQL name of the column
   * @return a Java input stream that delivers the database column value
   *   as a stream of uninterpreted bytes.  If the value is SQL NULL
   *   then the result is null.
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public java.io.InputStream getBinaryStream (String columnName) throws java.sql.SQLException
  {
    return getBinaryStream (findColumn (columnName));
  }  

  //=====================================================================
  // Advanced features:
  //=====================================================================

  /**
   * The first warning reported by calls on this ResultSet is
   * returned. Subsequent ResultSet warnings will be chained to this
   * SQLWarning.
   *
   * <P>The warning chain is automatically cleared each time a new
   * row is read.
   *
   * <P><B>Note:</B> This warning chain only covers warnings caused
   * by ResultSet methods.  Any warning caused by statement methods
   * (such as reading OUT parameters) will be chained on the
   * Statement object.
   *
   * @return the first SQLWarning or null
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  public java.sql.SQLWarning getWarnings () throws java.sql.SQLException
  {
    return sqlWarnings_;
  }

  /**
   * After this call getWarnings returns null until a new warning is
   * reported for this ResultSet.
   *
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public void clearWarnings () throws java.sql.SQLException
  {
    sqlWarnings_ = null;
  }

  synchronized void setWarning (java.sql.SQLWarning e)
  {
    if (sqlWarnings_ != null)
      sqlWarnings_.setNextException (e);
    else
      sqlWarnings_ = e;
  }

  /**
   * Get the name of the SQL cursor used by this ResultSet.
   *
   * <P>In SQL, a result table is retrieved through a cursor that is
   * named. The current row of a result can be updated or deleted
   * using a positioned update/delete statement that references the
   * cursor name. To insure that the cursor has the proper isolation
   * level to support update, the cursor's select statement should be
   * of the form 'select for update'. If the 'for update' clause is
   * omitted the positioned updates may fail.
   *
   * <P>JDBC supports this SQL feature by providing the name of the
   * SQL cursor used by a ResultSet. The current row of a ResultSet
   * is also the current row of this SQL cursor.
   *
   * <P><B>Note:</B> If positioned update is not supported a
   * SQLException is thrown
   *
   * @return the ResultSet's SQL cursor name
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  public String getCursorName () throws java.sql.SQLException
  {
    return cursorName_;
  }

  /**
   * The number, types and properties of a ResultSet's columns
   * are provided by the getMetaData method.
   *
   * @return the description of a ResultSet's columns
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public java.sql.ResultSetMetaData getMetaData () throws java.sql.SQLException
  {
    checkForClosedCursor ();

    if (resultSetMetaData_ == null)
      resultSetMetaData_ = new ResultSetMetaData (this, jdbcNet_);
    return resultSetMetaData_;
  }

  /**
   * Get the value of a column in the current row as a Java object.
   *
   * <p>This method will return the value of the given column as a
   * Java object.  The type of the Java object will be the default
   * Java object type corresponding to the column's SQL type,
   * following the mapping for built-in types specified in the JDBC
   * spec.
   *
   * <p>This method may also be used to read datatabase specific
   * abstract data types.
   *
   * <p><b>JDBC 2.0 note:</b>
   * New behavior for getObject().
   * The behavior of method getObject() is extended to materialize
   * data of SQL user-defined types.  When the column <code>columnIndex</code> is
   * a structured or distinct value, the behavior of this method is as
   * if it were a call to:
   * <pre>
   * getObject(columnIndex, this.getStatement().getConnection().getTypeMap())
   * </pre>
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return a java.lang.Object holding the column value.
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1, with extended behavior in JDBC 2</font>
   **/
  synchronized public Object getObject (int column) throws java.sql.SQLException
  {
    switch (resultTypes_[column-1]) {
    case IBTypes.CHAR__:
    case IBTypes.VARCHAR__:
    case IBTypes.CLOB__:
      return getString (column);
    case IBTypes.BLOB__:
      return getBytes (column);
    case IBTypes.ARRAY__:
      // MMM - changed getBytes() to getArray()
      return getArray (column);
      // MMM - end
    case IBTypes.DATE__:
      return getTimestamp (column);
    case IBTypes.NUMERIC_SMALLINT__:
    case IBTypes.NUMERIC_INTEGER__:
    case IBTypes.NUMERIC_DOUBLE__:
      return getBigDecimal (column, resultScales_[column-1]);
// CJL-IB6 add support for new types
    case IBTypes.NUMERIC_INT64__:
    case IBTypes.DECIMAL_INT64__:
    case IBTypes.DECIMAL_INTEGER__:
      return getBigDecimal (column, resultScales_[column-1]);
    case IBTypes.SQLDATE__:
      return getDate (column);
    case IBTypes.TIME__:
      return getTime (column);
// CJL-IB6 end changes
    case IBTypes.DOUBLE__:
      return new Double (getDouble (column));
    case IBTypes.FLOAT__:
      return new Float (getFloat (column));
    case IBTypes.SMALLINT__:
      return new Integer (getShort (column));
    case IBTypes.INTEGER__:
      return new Integer (getInt (column));
    default:
      throw new BugCheckException (ErrorKey.bugCheck__0__, 115);
    }
  }

  /**
   * <p>Get the value of a column in the current row as a Java object.
   *
   * <p>This method will return the value of the given column as a
   * Java object.  The type of the Java object will be the default
   * Java object type corresponding to the column's SQL type,
   * following the mapping for built-in types specified in the JDBC
   * spec.
   *
   * <p>This method may also be used to read datatabase specific
   * abstract data types.
   *
   * <p><b>JDBC 2.0 note:</b>
   * New behavior for getObject().
   * The behavior of method getObject() is extended to materialize
   * data of SQL user-defined types.  When the column <code>columnName</code> is
   * a structured or distinct value, the behavior of this method is as
   * if it were a call to:
   * <pre>
   * getObject(columnName, this.getStatement().getConnection().getTypeMap())
   * </pre>
   *
   * @param columnName is the SQL name of the column
   * @return a java.lang.Object holding the column value.
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1, with extended behavior in JDBC 2</font>
   **/
  synchronized public Object getObject (String columnName) throws java.sql.SQLException
  {
    return getObject (findColumn (columnName));
  }

  /**
   * Map a Resultset column name to a ResultSet column index.
   *
   * @param columnName the name of the column
   * @return the column index
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 1</font>
   **/
  synchronized public int findColumn (String columnName) throws java.sql.SQLException
  {
    // Create cache if it doesn't exist
    if (columnNameToIndexCache_ == null) {
      columnNameToIndexCache_ = new java.util.Hashtable ();
    }
    else { // Check cache for mapping
      Integer index = (Integer) columnNameToIndexCache_.get (columnName);
      if (index != null)
	return index.intValue ();
    }

    // Ok, we'll have to search the metadata
    for (int col = 0; col < resultCols_; col++) {
      //Torsten-start 08-11-2000
      //old code-start
      if ( resultColumnNames_[col].equalsIgnoreCase(columnName) ||
           resultColumnLabels_[col].equalsIgnoreCase(columnName)) {
      //if (resultColumnNames_[col].equalsIgnoreCase (columnName)) {
      //old code-end
      //Torsten-end 08-11-2000

	// Found it, add it to the cache
	columnNameToIndexCache_.put (columnName, new Integer (col+1));
	return col+1;
      }
    }
    
    throw new InvalidArgumentException (ErrorKey.invalidArgument__column_name_0__,
					columnName);
  }  
  
  void recv_ResultMetaData (RecvMessage recvMsg) throws java.sql.SQLException
  {
    if (Globals.debug__) {
      Globals.trace ("Result set meta data:");
      Globals.trace ("result cols = " + resultCols_);
    }
    for (int i = 0; i < resultCols_; i++) {
      resultTableNames_[i] = recvMsg.readLDSQLText ();
      resultColumnNames_[i] = recvMsg.readLDSQLText ();

      if (recvMsg.readBoolean ())  // column Name is the same as column label
        resultColumnLabels_[i] = resultColumnNames_[i];
      else
        resultColumnLabels_[i] = recvMsg.readLDSQLText ();
        
      resultNullables_[i] = recvMsg.readBoolean ();
      resultTypes_[i] = recvMsg.readUnsignedByte ();
      resultPrecisions_[i] = recvMsg.readUnsignedShort ();  // adjusted sqllen
      resultScales_[i] = recvMsg.readUnsignedByte ();       // sqlscale
      resultCharSets_[i] = recvMsg.readUnsignedShort ();    // sqlsubtype for CHAR/VARCHAR
      resultCharLengths_[i] = recvMsg.readUnsignedShort (); // computed from unadjusted sqllen
      // MMM - get an array descriptor
      // If column is of ARRAY data type, get an array descriptor
      if (resultTypes_[i] == IBTypes.ARRAY__ && recvMsg.readBoolean()) {
        arrayDescriptors_[i] = new ArrayDescriptor(recvMsg);
      }
      // MMM - end

      if (Globals.debug__) {
        Globals.trace ("result column name " + resultColumnNames_[i]);
        Globals.trace ("result column label " + resultColumnLabels_[i]);
        Globals.trace ("result nullable " + resultNullables_[i]);
        Globals.trace ("result type " + resultTypes_[i]);
        Globals.trace ("result precision " + resultPrecisions_[i]);
        Globals.trace ("result scale " + resultScales_[i]);
        Globals.trace ("result char set " + resultCharSets_[i]);
        Globals.trace ("result char length " + resultCharLengths_[i]);
      }
    }
    allocateCbuf ();
  }

  //--------------------------JDBC 2.0-----------------------------------

  //---------------------------------------------------------------------
  // Getter's and Setter's
  //---------------------------------------------------------------------

  /**
   * Get the value of a column in the current row as a java.io.Reader.
   *
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public java.io.Reader getCharacterStream (int columnIndex) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Get the value of a column in the current row as a java.io.Reader.
   *
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public java.io.Reader getCharacterStream (String columnName) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Get the value of a column in the current row as a java.math.BigDecimal
   * object.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value (full precision); if the value is SQL NULL,
   *   the result is null
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public java.math.BigDecimal getBigDecimal (int columnIndex) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Get the value of a column in the current row as a java.math.BigDecimal
   * object.
   *
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public java.math.BigDecimal getBigDecimal (String columnName) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  //---------------------------------------------------------------------
  // Traversal/Positioning
  //---------------------------------------------------------------------

  /**
   * Determine if the cursor is before the first row in the result
   * set.
   *
   * @return true if before the first row, false otherwise. Returns
   *   false when the result set contains no rows.
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public boolean isBeforeFirst () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Determine if the cursor is after the last row in the result
   * set.
   *
   * @return true if after the last row, false otherwise.  Returns
   *   false when the result set contains no rows.
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public boolean isAfterLast () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Determine if the cursor is on the first row of the result set.
   *
   * @return true if on the first row, false otherwise.
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public boolean isFirst () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Determine if the cursor is on the last row of the result set.
   * Note: Calling isLast() may be expensive since the JDBC driver
   * might need to fetch ahead one row in order to determine
   * whether the current row is the last row in the result set.
   *
   * @return true if on the last row, false otherwise.
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public boolean isLast () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Moves to the front of the result set, just before the
   * first row. Has no effect if the result set contains no rows.
   *
   * @throws java.sql.SQLException if a database-access error occurs, or
   *   result set type is TYPE_FORWARD_ONLY
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void beforeFirst () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Moves to the end of the result set, just after the last
   * row.  Has no effect if the result set contains no rows.
   *
   * @throws java.sql.SQLException if a database-access error occurs, or
   *   result set type is TYPE_FORWARD_ONLY.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void afterLast () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Moves to the first row in the result set.
   *
   * @return true if on a valid row, false if no rows in the result set.
   * @throws java.sql.SQLException if a database-access error occurs, or
   *   result set type is TYPE_FORWARD_ONLY.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public boolean first () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Moves to the last row in the result set.
   *
   * @return true if on a valid row, false if no rows in the result set.
   * @throws java.sql.SQLException if a database access error occurs, or
   *   result set type is TYPE_FORWARD_ONLY.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public boolean last () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Determine the current row number.  The first row is number 1, the
   * second number 2, etc.
   *
   * @return the current row number, else return 0 if there is no current row
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public int getRow () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Move to an absolute row number in the result set.
   *
   * <p>If row is positive, moves to an absolute row with respect to the
   * beginning of the result set.  The first row is row 1, the second
   * is row 2, etc.
   *
   * <p>If row is negative, moves to an absolute row position with respect to
   * the end of result set.  For example, calling absolute(-1) positions the
   * cursor on the last row, absolute(-2) indicates the next-to-last
   * row, etc.
   *
   * <p>An attempt to position the cursor beyond the first/last row in
   * the result set, leaves the cursor before/after the first/last
   * row, respectively.
   *
   * <p>Note: Calling absolute(1) is the same as calling first().
   * Calling absolute(-1) is the same as calling last().
   *
   * @return true if on the result set, false if off.
   * @throws java.sql.SQLException if a database access error occurs, or
   *   row is 0, or result set type is TYPE_FORWARD_ONLY.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public boolean absolute (int row) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Moves a relative number of rows, either positive or negative.
   * Attempting to move beyond the first/last row in the
   * result set positions the cursor before/after the
   * the first/last row. Calling relative(0) is valid, but does
   * not change the cursor position.
   *
   * <p>Note: Calling relative(1) is different than calling next()
   * since is makes sense to call next() when there is no current row,
   * for example, when the cursor is positioned before the first row
   * or after the last row of the result set.
   *
   * @return true if on a row, false otherwise.
   * @throws java.sql.SQLException if a database access error occurs, or there
   *   is no current row, or result set type is TYPE_FORWARD_ONLY.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public boolean relative (int rows) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Moves to the previous row in the result set.
   *
   * <p>Note: previous() is not the same as relative(-1) since it
   * makes sense to call previous() when there is no current row.
   *
   * @return true if on a valid row, false if off the result set.
   * @throws java.sql.SQLException if a database access error occurs, or
   *   result set type is TYPE_FORWAR_DONLY.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public boolean previous () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  //---------------------------------------------------------------------
  // Properties
  //---------------------------------------------------------------------

  /**
   * The rows in a result set will be processed in a forward direction;
   * first-to-last.
   *
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  final public static int FETCH_FORWARD = 1000;
  //*end jre12*

  /**
   * The rows in a result set will be processed in a reverse direction;
   * last-to-first.
   *
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  final static public int FETCH_REVERSE = 1001;
  //*end jre12*

  /**
   * The order in which rows in a result set will be processed is unknown.
   *
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  final static public int FETCH_UNKNOWN = 1002;
  //*end jre12*

  /**
   * Give a hint as to the direction in which the rows in this result set
   * will be processed.  The initial value is determined by the statement
   * that produced the result set.  The fetch direction may be changed
   * at any time.
   *
   * @throws java.sql.SQLException if a database access error occurs, or
   *   the result set type is TYPE_FORWARD_ONLY and direction is not
   *   FETCH_FORWARD.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void setFetchDirection (int direction) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Return the fetch direction for this result set.
   *
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public int getFetchDirection () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Give the JDBC driver a hint as to the number of rows that should
   * be fetched from the database when more rows are needed for this result
   * set.  If the fetch size specified is zero, then the JDBC driver
   * ignores the value, and is free to make its own best guess as to what
   * the fetch size should be.  The default value is set by the statement
   * that creates the result set.  The fetch size may be changed at any
   * time.
   *
   * @param rows the number of rows to fetch
   * @throws java.sql.SQLException if a database access error occurs, or the
   *   condition 0 <= rows <= this.getMaxRows() is not satisfied.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void setFetchSize (int rows) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Return the fetch size for this result set.
   *
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public int getFetchSize () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  final static public int TYPE_FORWARD_ONLY = 1003;
  //*end jre12*

  /**
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  final static public int TYPE_SCROLL_INSENSITIVE = 1004;
  //*end jre12*

  /**
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  final static public int TYPE_SCROLL_SENSITIVE = 1005;
  //*end jre12*

  /**
   * Return the type of this result set.  The type is determined based
   * on the statement that created the result set.
   *
   * @return TYPE_FORWARD_ONLY, TYPE_SCROLL_INSENSITIVE, or TYPE_SCROLL_SENSITIVE
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public int getType () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  final static public int CONCUR_READ_ONLY = 1007;
  //*end jre12*

  /**
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  final static public int CONCUR_UPDATABLE = 1008;
  //*end jre12*

  /**
   * Return the concurrency of this result set.  The concurrency
   * used is determined by the statement that created the result set.
   *
   * @return the concurrency type, CONCUR_READ_ONLY, etc.
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public int getConcurrency () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  //---------------------------------------------------------------------
  // Updates
  //---------------------------------------------------------------------

  /**
   * Determine if the current row has been updated.  The value returned
   * depends on whether or not the result set can detect updates.
   *
   * @return true if the row has been visibly updated by the owner or
   *   another, and updates are detected
   * @throws java.sql.SQLException if a database access error occurs
   * @see DatabaseMetaData#updatesAreDetected
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public boolean rowUpdated () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Determine if the current row has been inserted.  The value returned
   * depends on whether or not the result set can detect visible inserts.
   *
   * @return true if inserted and inserts are detected
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   * @see DatabaseMetaData#insertsAreDetected
   **/ //*start jre12*
  synchronized public boolean rowInserted () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Determine if this row has been deleted.  A deleted row may leave
   * a visible "hole" in a result set.  This method can be used to
   * detect holes in a result set.  The value returned depends on whether
   * or not the result set can detect deletions.
   *
   * @return true if deleted and deletes are detected
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   * @see DatabaseMetaData#deletesAreDetected
   **/ //*start jre12*
  synchronized public boolean rowDeleted () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Give a nullable column a null value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateNull (int columnIndex) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a boolean value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateBoolean (int columnIndex,
                                          boolean x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a byte value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateByte (int columnIndex,
                                       byte x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a short value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateShort (int columnIndex,
                                        short x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with an integer value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateInt (int columnIndex,
                                      int x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a long value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateLong (int columnIndex,
                                       long x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a float value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateFloat (int columnIndex,
                                        float x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a Double value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateDouble (int columnIndex,
                                         double x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a BigDecimal value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateBigDecimal (int columnIndex,
                                             java.math.BigDecimal x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a String value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateString (int columnIndex,
                                         String x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a byte array value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateBytes (int columnIndex,
                                        byte x[]) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a Date value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateDate (int columnIndex,
                                       java.sql.Date x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a Time value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateTime (int columnIndex,
                                       java.sql.Time x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a Timestamp value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateTimestamp (int columnIndex,
                                            java.sql.Timestamp x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with an ascii stream value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @param length the length of the stream
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateAsciiStream (int columnIndex,
			                     java.io.InputStream x,
			                     int length) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a binary stream value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @param length the length of the stream
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateBinaryStream (int columnIndex,
			                      java.io.InputStream x,
			                      int length) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a character stream value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @param length the length of the stream
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateCharacterStream (int columnIndex,
			                          java.io.Reader x,
			                          int length) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with an Object value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @param scale For java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types
   *  this is the number of digits after the decimal.  For all other
   *  types this value will be ignored.
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateObject (int columnIndex,
                                         Object x,
                                         int scale) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with an Object value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateObject(int columnIndex, Object x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a null value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateNull (String columnName) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a boolean value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateBoolean (String columnName,
                                          boolean x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a byte value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateByte (String columnName,
                                       byte x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a short value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateShort (String columnName,
                                        short x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with an integer value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateInt (String columnName,
                                      int x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a long value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateLong (String columnName,
                                       long x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a float value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateFloat (String columnName,
                                        float x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a double value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateDouble (String columnName,
                                         double x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a BigDecimal value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateBigDecimal (String columnName, java.math.BigDecimal x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a String value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateString (String columnName,
                                         String x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a byte array value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateBytes (String columnName,
                                        byte x[]) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a Date value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateDate (String columnName,
                                       java.sql.Date x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a Time value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateTime (String columnName,
                                       java.sql.Time x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a Timestamp value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateTimestamp (String columnName,
                                            java.sql.Timestamp x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with an ascii stream value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @param length of the stream
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateAsciiStream (String columnName,
			                      java.io.InputStream x,
			                      int length) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a binary stream value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @param length of the stream
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateBinaryStream (String columnName,
			                       java.io.InputStream x,
			                       int length) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with a character stream value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @param length of the stream
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateCharacterStream (String columnName,
			                          java.io.Reader reader,
			                          int length) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with an Object value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @param scale For java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types
   *  this is the number of digits after the decimal.  For all other
   *  types this value will be ignored.
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateObject (String columnName,
                                         Object x,
                                         int scale) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update a column with an Object value.
   *
   * The updateXXX() methods are used to update column values in the
   * current row, or the insert row.  The updateXXX() methods do not
   * update the underlying database, instead the updateRow() or insertRow()
   * methods are called to update the database.
   *
   * @param columnName the name of the column
   * @param x the new column value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateObject (String columnName,
                                         Object x) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Insert the contents of the insert row into the result set and
   * the database.  Must be on the insert row when this method is called.
   *
   * @throws java.sql.SQLException if a database access error occurs,
   *   if called when not on the insert row, or if all non-nullable columns in
   *   the insert row have not been given a value
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void insertRow () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Update the underlying database with the new contents of the
   * current row.  Cannot be called when on the insert row.
   *
   * @throws java.sql.SQLException if a database access error occurs, or
   *   if called when on the insert row
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void updateRow () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Delete the current row from the result set and the underlying
   * database.  Cannot be called when on the insert row.
   *
   * @throws java.sql.SQLException if a database access error occurs, or if
   *   called when on the insert row.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void deleteRow () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Refresh the value of the current row with its current value in
   * the database.  Cannot be called when on the insert row.
   *
   * The refreshRow() method provides a way for an application to
   * explicitly tell the JDBC driver to refetch a row(s) from the
   * database.  An application may want to call refreshRow() when
   * caching or prefetching is being done by the JDBC driver to
   * fetch the latest value of a row from the database.  The JDBC driver
   * may actually refresh multiple rows at once if the fetch size is
   * greater than one.
   *
   * All values are refetched subject to the transaction isolation
   * level and cursor sensitivity.  If refreshRow() is called after
   * calling updateXXX(), but before calling updateRow() then the
   * updates made to the row are lost.  Calling refreshRow() frequently
   * will likely slow performance.
   *
   * @throws java.sql.SQLException if a database access error occurs, or if
   *   called when on the insert row.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void refreshRow () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * The cancelRowUpdates() method may be called after calling an
   * updateXXX() method(s) and before calling updateRow() to rollback
   * the updates made to a row.  If no updates have been made or
   * updateRow() has already been called, then this method has no
   * effect.
   *
   * @throws java.sql.SQLException if a database access error occurs, or if
   *   called when on the insert row.
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void cancelRowUpdates () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Move to the insert row.  The current cursor position is
   * remembered while the cursor is positioned on the insert row.
   *
   * The insert row is a special row associated with an updatable
   * result set.  It is essentially a buffer where a new row may
   * be constructed by calling the updateXXX() methods prior to
   * inserting the row into the result set.
   *
   * Only the updateXXX(), getXXX(), and insertRow() methods may be
   * called when the cursor is on the insert row.  All of the columns in
   * a result set must be given a value each time this method is
   * called before calling insertRow().  UpdateXXX()must be called before
   * getXXX() on a column.
   *
   * @throws java.sql.SQLException if a database access error occurs,
   *   or the result set is not updatable
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void moveToInsertRow () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Move the cursor to the remembered cursor position, usually the
   * current row.  Has no effect unless the cursor is on the insert
   * row.
   *
   * @throws java.sql.SQLException if a database access error occurs,
   *   or the result set is not updatable
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public void moveToCurrentRow () throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Returns the Statement that produced this ResultSet.
   *
   * @return the Statement that produced the result set, or
   *   null if the result was produced some other way.
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, since InterClient 1.50</font>
   **/ 
  synchronized public java.sql.Statement getStatement () throws java.sql.SQLException
  {
    return statement_;
  }

  /**
   * Returns the value of result <code>column</code> as a Java object.  Use the
   * <code>map</code> to determine the class from which to construct data of
   * SQL structured and distinct types.
   *
   * @param column the first column is 1, the second is 2, ...
   * @param map the mapping from SQL type names to Java classes
   * @return an object representing the SQL value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public Object getObject (int column,
                                        java.util.Map map) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Get a REF(&lt;structured-type&gt;) column.
   *
   * @param column the first column is 1, the second is 2, ...
   * @return an object representing data of an SQL REF type
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public java.sql.Ref getRef (int column) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Gets a BLOB column.
   *
   * @param column the first column is 1, the second is 2, ...
   * @return an object representing a BLOB
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public java.sql.Blob getBlob (int column) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Get a CLOB column.
   *
   * @param column the first column is 1, the second is 2, ...
   * @return an object representing a CLOB
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public java.sql.Clob getClob (int column) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  // MMM - added getArray (int)
  /**
   * Gets an array column.
   *
   * @param column the first column is 1, the second is 2, ...
   * @return an object representing an SQL array
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, proposed for InterClient 3.0</font>
   **/ //*start jre12*
// CJL-IB6 changed reference to InterClient 2.0
  synchronized public java.sql.Array getArray (int column) throws java.sql.SQLException
  {
    if (isNullPreamble (column))
      return null;

    switch (resultTypes_[column-1]) {
    case IBTypes.ARRAY__:
      return new Array (getRowData_arrayId(column-1),
                        arrayDescriptors_[column-1],
                        statement_.connection_);

    default:
      throw new ColumnConversionException (ErrorKey.columnConversion__type_conversion__);
    }
  }
  //*end jre12*
  // MMM - end

  /**
   * Returns the value of a result column as a Java object.  Use the
   * <code>map</code> to determine the class from which to construct data of
   * SQL structured and distinct types.
   *
   * @param columnName the column name
   * @param map the mapping from SQL type names to Java classes
   * @return an object representing the SQL value
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public Object getObject (String columnName,
                                        java.util.Map map) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Get a REF(&lt;structured-type&gt;) column.
   *
   * @param columnName the column name
   * @return an object representing data of an SQL REF type
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public java.sql.Ref getRef (String columnName) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Gets a BLOB column.
   *
   * @param columnName the column name
   * @return an object representing a BLOB
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public java.sql.Blob getBlob (String columnName) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Gets a CLOB column.
   *
   * @param columnName the column name
   * @return an object representing a CLOB
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public java.sql.Clob getClob (String columnName) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  // MMM - added getArray (String)
  /**
   * Gets an array column.
   *
   * @param columnName the column name
   * @return an object representing an SQL array
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, proposed for InterClient 3.0</font>
   **/ //*start jre12*
// CJL-IB6 changed reference to InterClient 2.0
  synchronized public java.sql.Array getArray (String columnName) throws java.sql.SQLException
  {
    return getArray (findColumn (columnName));
  }
  //*end jre12*
  // MMM - end

  /**
   * Gets the value of a column in the current row as a java.sql.Date
   * object.  Use the calendar to construct an appropriate millisecond
   * value for the Date, if the underlying database doesn't store
   * timezone information.
   *
   * @param column the first column is 1, the second is 2, ...
   * @param cal the calendar to use in constructing the date
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public java.sql.Date getDate (int column,
                                             java.util.Calendar cal) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Gets the value of a column in the current row as a java.sql.Date object.
   * Use the calendar to construct an appropriate millisecond
   * value for the Date, if the underlying database doesn't store
   * timezone information.
   *
   * @param columnName is the SQL name of the column
   * @param cal the calendar to use in constructing the date
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public java.sql.Date getDate (String columnName,
                                             java.util.Calendar cal) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Gets the value of a column in the current row as a java.sql.Time
   * object. Use the calendar to construct an appropriate millisecond
   * value for the Time, if the underlying database doesn't store
   * timezone information.
   *
   * @param column the first column is 1, the second is 2, ...
   * @param cal the calendar to use in constructing the time
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public java.sql.Time getTime (int column,
                                             java.util.Calendar cal) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Gets the value of a column in the current row as a java.sql.Time
   * object. Use the calendar to construct an appropriate millisecond
   * value for the Time, if the underlying database doesn't store
   * timezone information.
   *
   * @param columnName is the SQL name of the column
   * @param cal the calendar to use in constructing the time
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public java.sql.Time getTime (String columnName,
                                             java.util.Calendar cal) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Gets the value of a column in the current row as a java.sql.Timestamp
   * object. Use the calendar to construct an appropriate millisecond
   * value for the Timestamp, if the underlying database doesn't store
   * timezone information.
   *
   * @param column the first column is 1, the second is 2, ...
   * @param cal the calendar to use in constructing the timestamp
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public java.sql.Timestamp getTimestamp (int column,
                                                       java.util.Calendar cal) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  /**
   * Gets the value of a column in the current row as a java.sql.Timestamp
   * object. Use the calendar to construct an appropriate millisecond
   * value for the Timestamp, if the underlying database doesn't store
   * timezone information.
   *
   * @param columnName is the SQL name of the column
   * @param cal the calendar to use in constructing the timestamp
   * @return the column value; if the value is SQL NULL, the result is null
   * @throws java.sql.SQLException if a database access error occurs
   * @since <font color=red>JDBC 2, not yet supported</font>
   **/ //*start jre12*
  synchronized public java.sql.Timestamp getTimestamp (String columnName,
                                                       java.util.Calendar cal) throws java.sql.SQLException
  {
    throw new DriverNotCapableException (ErrorKey.driverNotCapable__jdbc2_not_yet_supported__);
  }
  //*end jre12*

  // ----------------------InterClient Extensions--------------------------

  // How many selected rows are associated with this result set.
  // This didn't work, leaving this here as a placeholder but
  // zeroed out values sent from server so as to
  // avoid a call to isc_dsql_info.
  // isc_dsql_info just returns 0 for row count on select, 
  // probably interbase bug.
  // 
  // public int getRowCount () throws SQLException
  // {
  //   return numRows_;
  // }

  /**
   * Is the column value a SQL NULL.
   * <p>
   * Unlike other drivers, InterClient does not require
   * that a column be read before it is checked for NULL.
   *
   * @see #wasNull
   * @since <font color=red>Extension, since InterClient 1.0</font>
   * @throws java.sql.SQLException if a database access error occurs.
   **/
  public boolean isNull (int column) throws java.sql.SQLException
  {
    checkForClosedCursor ();
    checkForValidCursorPosition ();

    try {
      return isNull_[column-1];
    }
    catch (ArrayIndexOutOfBoundsException e) {
      throw new ColumnIndexOutOfBoundsException (ErrorKey.columnIndexOutOfBounds__0__,
						 column);
    }
  }

  /**
   * Adapt this result set object as described by a <code>modifier</code>
   * in the {@link Adaptor Adaptor} interface.
   * 
   * @param modifier is either
   *   {@link Adaptor#RIGHT_TRIM_STRINGS Adaptor.RIGHT_TRIM_STRINGS} or
   *   {@link Adaptor#SINGLE_INSTANCE_TIME Adaptor.SINGLE_INSTANCE_TIME}
   * @param extraInfo any extra information that needs to be specified along with the modifier;
   *        currently unused.
   * @return true if the modifier is supported, false otherwise.
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>Extension, since InterClient 1.0</font>
   **/
  synchronized public boolean adapt (int modifier, 
                                     Object extraInfo) throws java.sql.SQLException
  {
    switch (modifier) {
    case Adaptor.RIGHT_TRIM_STRINGS:
      adaptToRightTrimString_ = true;
      return true;

    case Adaptor.SINGLE_INSTANCE_TIME:
      adaptToSingleInstanceTime_ = true;
      adaptableIBTimestamp_ = new IBTimestamp (0, 0, 1);
      adaptableDate_ = new java.sql.Date (0);
      adaptableTime_ = new java.sql.Time (0);
      adaptableTimestamp_ = new java.sql.Timestamp (0);
      return true;

    default:
      return false;
    }
  }

  /**
   * Revert back to default JDBC behavior for this object previously
   * adapted for the modification described by the given <code>modifier</code>.
   * 
   * @param modifier is either
   *   {@link Adaptor#RIGHT_TRIM_STRINGS Adaptor.RIGHT_TRIM_STRINGS} or
   *   {@link Adaptor#SINGLE_INSTANCE_TIME Adaptor.SINGLE_INSTANCE_TIME}
   * @throws java.sql.SQLException if a database access error occurs.
   * @since <font color=red>Extension, since InterClient 1.0</font>
   **/
  synchronized public void revert (int modifier) throws java.sql.SQLException
  {
    switch (modifier) {
    case Adaptor.RIGHT_TRIM_STRINGS:
      adaptToRightTrimString_ = false;
      break;
    case Adaptor.SINGLE_INSTANCE_TIME:
      adaptToSingleInstanceTime_ = false;
      break;

    default:
      break;
    }
  }

  // Returns true if column data is null.
  // Throws an exception if column index is bad, or at invalid
  // row position.
  private boolean isNullPreamble (int column) throws java.sql.SQLException
  {
    checkForClosedCursor ();

    checkForValidCursorPosition ();

    try {
      if (isNull_[column-1]) {
	wasNull_ = WAS_NULL__;
	return true;
      }
      else {
	wasNull_ = WAS_NOT_NULL__;
	return false;
      }
    }
    catch (ArrayIndexOutOfBoundsException e) {
      throw new ColumnIndexOutOfBoundsException (ErrorKey.columnIndexOutOfBounds__0__,
						 column);
    }
  }    
}
