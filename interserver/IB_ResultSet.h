/*
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 */
//-*-C++-*-
#ifndef _IB_RESULT_SET_H_
#define _IB_RESULT_SET_H_

#include "IB_Defines.h"
#include "IB_SQLException.h"
#include "IB_DataBuffer.h"
#include "IB_LDString.h"
#include "IB_Statement.h"
#include "IB_Status.h"
#include "IB_Transaction.h"
#include "IB_Connection.h"

// IB_ResultSet provides access to a table of data generated by
// executing a Statement. The table rows are retrieved in sequence.
// Within a row its column values can be accessed in any order.
// 
// ResultSet maintains a cursor pointing to its current row of
// data.  Initially the cursor is positioned before the first row.
// The 'next' method moves the cursor to the next row.
//
// The ResultSet.get methods retrieve column values for the current
// row.  You can retrieve values by using the index number of the
// column.  Columns are numbered from 0.
//
// A ResultSet is automatically closed by the Statement that
// generated it when that Statement is closed, re-executed, or is used
// to retrieve the next result from a sequence of multiple results.

class IB_ResultSet : public IB_DataBuffer 
{

private:

  IB_Statement* statement_;

  // Keep track of whether the result set cursor is open.
  // The need for this is that when the result set is closed,
  // we can know if we should make a server request to close the cursor.
  // Also, if a statement is re-executed we need to know to close
  // the previous cursor before opening a new one.
  IB_BOOLEAN open_;

  IB_SSHORT16 maxFieldSize_;
  IB_SLONG32 fetchSize_;

  int catalogFunction_;

  // Inherits sqldaOut_, buffer_ and recordSize_ from IB_DataBuffer

public:

  ~IB_ResultSet ();

  // The maxFieldSize limit (in bytes) is the maximum amount of data returned for
  // any column value; it only applies to BLOB, CHAR, and VARCHAR columns.
  // If the limit is exceeded, the excess data is silently discarded.
  IB_SSHORT16 getMaxFieldSize () const;

  // The maxFieldSize limit (in bytes) is set to limit the size of
  // data that can be returned for any column value; it only applies
  // to BINARY, VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and
  // LONGVARCHAR fields.  If the limit is exceeded, the excess data
  // is silently discarded.
  // maxFieldSize is the new max column size limit; zero means unlimited 
  void setMaxFieldSize (const IB_SSHORT16 maxFieldSize);

  IB_SLONG32 getFetchSize () const;
  void setFetchSize (const IB_SLONG32 fetchSize);

  // A ResultSet is initially positioned before its first row; the
  // first call to next makes the first row the current row; the
  // second call makes the second row the current row, etc. 
  // return true if the new current row is valid; false if there are no more rows.
  IB_BOOLEAN next ();

#ifdef IB_USER_API
  IB_BOOLEAN previous ();

  IB_BOOLEAN relative (const IB_BOOLEAN previous,
		       const IB_SLONG32 offset);
#endif
  
  // Makes server singleton fetch request.
  // Throws IB_SQLException if result set is open
  // or if server execute request fails.  
  void singletonFetch ();

  int getStatementType ();

  // Opens a server result set cursor (executes select statement).
  // Throws IB_SQLException if result set is already open,
  // or if server execute request fails.
  void open (); 

  // Close the cursor.
  // No-op if result set is already closed.
  // Once closed, a result set may be reopened by calling open().
  // However, calling Statement::prepare () will destroy this result set.
  void close ();

  IB_BOOLEAN isOpen () const;

  // Request server for row count information for
  // SELECT statements.
  // Throw IB_SQLException if server information request fails.
  IB_SLONG32 getRowCount ();

  // ***************************Result Set Data**************************

  // Is the result a SQL NULL.
  // A column may have the value of SQL NULL; isNull tests for
  // this special value. If a column isNull a get method may
  // still be called for it; however, the value returned is a
  // just placeholder that depends on the get method used.
  IB_BOOLEAN isNull (const IB_SSHORT16 columnIndex) const;

  // Get the SMALLINT result
  IB_SSHORT16 getSmallInt (const IB_SSHORT16 columnIndex) const;

  // Get the INTEGER result
  IB_SLONG32 getInteger (const IB_SSHORT16 columnIndex) const;

  // Get the FLOAT or REAL result
  IB_FLOAT32 getFloat (const IB_SSHORT16 columnIndex) const;

  // Get the DOUBLE result
  IB_DOUBLE64 getDouble (const IB_SSHORT16 columnIndex) const;

  // Get the NUMERIC or DECIMAL result as a scaled value
  IB_DOUBLE64 getNumericDouble (const IB_SSHORT16 columnIndex) const;

  // Get the NUMERIC or DECIMAL result as a scaled value
  IB_SLONG32 getNumericInteger (const IB_SSHORT16 columnIndex) const;

  // Get the NUMERIC or DECIMAL result as a scaled value
  IB_SSHORT16 getNumericSmallInt (const IB_SSHORT16 columnIndex) const;

  // Get the CHAR result as a non-null terminated string.
  // String is shared, not copied.
  IB_STRING getChar (const IB_SSHORT16 columnIndex) const;

  // Get the length of the CHAR result in bytes.
  // May be less than native length if maxFieldSize is set.
  IB_SSHORT16 getCharByteLength (const IB_SSHORT16 columnIndex) const;

  // Get the length of the right trimmed CHAR result in bytes.
  // May be less than native length if maxFieldSize is set.
  IB_SSHORT16 getCharTrimmedByteLength (const IB_SSHORT16 columnIndex) const;

  // Get the VARCHAR result as a length delimited string buffer ptr.
  // String is shared, not copied.  
  IB_STRING getVarChar (const IB_SSHORT16 columnIndex) const;

  // Get the length of the VARCHAR result in bytes.
  // May be less than native length if maxFieldSize is set.
  IB_SSHORT16 getVarCharByteLength (const IB_SSHORT16 columnIndex) const;

  // Get the LONGVARCHAR result as a blobId
  IB_BLOBID getAsciiBlob (const IB_SSHORT16 columnIndex) const;

  // Get the BINARY, VARBINARY or LONGVARBINARY result as a blobId
  IB_BLOBID getBinaryBlob (const IB_SSHORT16 columnIndex) const;

  // Get the LONGVARCHAR result as a blobId
  IB_BLOBID getUnicodeBlob (const IB_SSHORT16 columnIndex) const;

  // Get the DATE, TIME or TIMESTAMP result as a timestamp
  IB_TIMESTAMP getDate (const IB_SSHORT16 columnIndex) const;

  // Get the array.
  // Note - there is no XOPEN/SQL array type.
  IB_ARRAYID getArray (const IB_SSHORT16 columnIndex) const;

//CJL-IB6 added new types
	// Get 64-bit NUMERIC and DECIMAL results -- SQL Dialect 3 only
	IB_SINT64 getInt64 (const IB_SSHORT16 columnIndex) const;

	// Get SQL DATE result -- SQL Dialect 3 only
	IB_SLONG32 getSQLDate (const IB_SSHORT16 columnIndex) const;

	// Get TIME result -- SQL Dialect 3 only
	IB_ULONG32 getTime (const IB_SSHORT16 columnIndex) const;
// CJL-IB6 end change

  // **********************Result Set Meta Data*****************************

  IB_SSHORT16 getColumnCount () const;

   // HP-UX port (old CC): added 'inline'
  inline
  IB_BOOLEAN isColumnNullable (const IB_SSHORT16 columnIndex) const;

  IB_Types::IBType getColumnType (const IB_SSHORT16 columnIndex) const;

#ifdef IB_USER_API
  // string exists in static memory.
  IB_LDString getColumnTypeName (const IB_SSHORT16 columnIndex) const;
#endif

  // Suggested column title for use in printouts and displays
  // shared string exists in output descriptor area and is therefore invalid
  // after a prepare or close.
  IB_LDString getColumnLabel (const IB_SSHORT16 columnIndex) const;

  // SQL name for column
  // shared string exists in output descriptor area and is therefore invalid
  // after a prepare or close.
  IB_LDString getColumnName (const IB_SSHORT16 columnIndex) const;

  // Number of decimal digits
  IB_SSHORT16 getColumnPrecision (const IB_SSHORT16 columnIndex) const;

  // Number of digits to right of decimal
  IB_SSHORT16 getColumnScale (const IB_SSHORT16 columnIndex) const;

  // Value of sqlsubtype from XSQLVAR
  IB_SSHORT16 getColumnCharSet (const IB_SSHORT16 columnIndex) const;

  IB_SSHORT16 getColumnCharLength (const IB_SSHORT16 columnIndex) const;

  // Name of column's table, or "" if not applicable.
  // shared string exists in output descriptor area and is therefore invalid
  // after a prepare or close.
  IB_LDString getColumnTableName (const IB_SSHORT16 columnIndex) const;

  IB_BOOLEAN isColumnWritable (const IB_SSHORT16 columnIndex) const;


private:

  friend class IB_Statement;

  friend class IB_Catalog;
  void setCatalogFunction (const int catalogFunction);

  friend class JIBSRemote;
  int getCatalogFunction ();

  // The only way to create a result set is from statement prepare.
  // Throw SQLException if there is not enough memory on the heap.
  IB_ResultSet (const IB_Statement* statement,
		const IB_SSHORT16 maxFieldSize = 0);


};

inline
IB_ResultSet::IB_ResultSet (const IB_Statement* statement,
			    const IB_SSHORT16 maxFieldSize)
  : IB_DataBuffer (statement->sqldaOut_, statement->connection_->attachmentCharSetCode_),
    statement_ ((IB_Statement*) statement),
    open_ (IB_FALSE),
    maxFieldSize_ (maxFieldSize),
    fetchSize_ (0),
    catalogFunction_ (0)
{ 
#ifdef TRACEON
  debugTraceAnInt ("constructing result set: ", (IB_REF) this);
#endif
}

inline
IB_SLONG32 
IB_ResultSet::getRowCount ()
{
  return statement_->getUpdateCount ();
}

inline
void 
IB_ResultSet::setFetchSize (const IB_SLONG32 fetchSize)
{
  fetchSize_ = fetchSize;
}

inline
IB_SLONG32 
IB_ResultSet::getFetchSize () const
{
  return fetchSize_;
}

inline
void
IB_ResultSet::close ()
{
#ifdef TRACEON
  debugTraceAnInt ("closing result set: ", (IB_REF) this);
#endif
  if (!open_)
    return;

  statement_->dsqlCloseCursor (); 

  open_ = IB_FALSE;

  if (catalogFunction_) {
    statement_->transaction_->close ();
    statement_->close ();
  }
}

inline
IB_BOOLEAN
IB_ResultSet::isOpen () const
{
  return open_;
}

inline
void
IB_ResultSet::singletonFetch ()
{
  if (open_) // Attempt to singleton fetch an open result set
    throw new IB_SQLException (IB_SQLException::bugCheck__0__,
			       10023,
			       IB_SQLException::bugCheckException__);

  // !!! Does this open a cursor on the server which needs to be closed?
  statement_->dsqlSingletonFetch ();
}

inline
int
IB_ResultSet::getStatementType ()
{
  return statement_->getStatementType ();
}

inline
IB_BOOLEAN
IB_ResultSet::next ()
{
  return (statement_->dsqlFetch ());
}

inline
IB_BOOLEAN 
IB_ResultSet::isNull (const IB_SSHORT16 columnIndex) const
{
  if (!isColumnNullable (columnIndex))
    return IB_FALSE;
  else
    return TO_BOOLEAN (*(IB_SSHORT16*) (sqlda_->sqlvar+columnIndex)->sqlind);
}

// !!! need to set NullDataWarning's throughout the get routines.

inline
IB_SSHORT16 
IB_ResultSet::getSmallInt (const IB_SSHORT16 columnIndex) const
{
  IB_Types::typeCheck (IB_Types::SMALLINT_TYPE, sqlda_->sqlvar+columnIndex);

  return *(IB_SSHORT16*) (sqlda_->sqlvar+columnIndex)->sqldata;
}

inline
IB_SLONG32 
IB_ResultSet::getInteger (const IB_SSHORT16 columnIndex) const
{
  IB_Types::typeCheck (IB_Types::INTEGER_TYPE, sqlda_->sqlvar+columnIndex);

  return *(IB_SLONG32*) (sqlda_->sqlvar+columnIndex)->sqldata;
}

inline
IB_FLOAT32 
IB_ResultSet::getFloat (const IB_SSHORT16 columnIndex) const
{
  IB_Types::typeCheck (IB_Types::FLOAT_TYPE, sqlda_->sqlvar+columnIndex);

  return *(IB_FLOAT32*) (sqlda_->sqlvar+columnIndex)->sqldata;
}

inline
IB_DOUBLE64 
IB_ResultSet::getDouble (const IB_SSHORT16 columnIndex) const
{
  IB_Types::typeCheck (IB_Types::DOUBLE_TYPE, sqlda_->sqlvar+columnIndex);

  return *(IB_DOUBLE64*) (sqlda_->sqlvar+columnIndex)->sqldata;
}

inline
IB_DOUBLE64 
IB_ResultSet::getNumericDouble (const IB_SSHORT16 columnIndex) const
{
  IB_Types::typeCheck (IB_Types::NUMERIC_DOUBLE_TYPE, sqlda_->sqlvar+columnIndex);

  return *(IB_DOUBLE64*) (sqlda_->sqlvar+columnIndex)->sqldata;
}

inline
IB_SLONG32 
IB_ResultSet::getNumericInteger (const IB_SSHORT16 columnIndex) const
{
  IB_Types::typeCheck (IB_Types::NUMERIC_INTEGER_TYPE, sqlda_->sqlvar+columnIndex);

  return *(IB_SLONG32*) (sqlda_->sqlvar+columnIndex)->sqldata;
}

inline
IB_SSHORT16 
IB_ResultSet::getNumericSmallInt (const IB_SSHORT16 columnIndex) const
{
  IB_Types::typeCheck (IB_Types::NUMERIC_SMALLINT_TYPE, sqlda_->sqlvar+columnIndex);

  return *(IB_SSHORT16*) (sqlda_->sqlvar+columnIndex)->sqldata;
}

inline
IB_BLOBID 
IB_ResultSet::getAsciiBlob (const IB_SSHORT16 columnIndex) const
{
  IB_Types::typeCheck (IB_Types::CLOB_TYPE, sqlda_->sqlvar+columnIndex);

  return *(IB_BLOBID*) (sqlda_->sqlvar+columnIndex)->sqldata;
}

inline
IB_BLOBID 
IB_ResultSet::getBinaryBlob (const IB_SSHORT16 columnIndex) const
{
  IB_Types::typeCheck (IB_Types::BLOB_TYPE, sqlda_->sqlvar+columnIndex);

  return *(IB_BLOBID*) (sqlda_->sqlvar+columnIndex)->sqldata;
}

inline
IB_BLOBID 
IB_ResultSet::getUnicodeBlob (const IB_SSHORT16 columnIndex) const
{
  IB_Types::typeCheck (IB_Types::CLOB_TYPE, sqlda_->sqlvar+columnIndex);

  return *(IB_BLOBID*) (sqlda_->sqlvar+columnIndex)->sqldata;
}

inline
IB_TIMESTAMP 
IB_ResultSet::getDate (const IB_SSHORT16 columnIndex) const
{
  IB_Types::typeCheck (IB_Types::DATE_TYPE, sqlda_->sqlvar+columnIndex);

  return *(IB_TIMESTAMP*) (sqlda_->sqlvar+columnIndex)->sqldata;
}

inline
IB_ARRAYID 
IB_ResultSet::getArray (const IB_SSHORT16 columnIndex) const
{
  IB_Types::typeCheck (IB_Types::ARRAY_TYPE, sqlda_->sqlvar+columnIndex);

  return *(IB_ARRAYID*) (sqlda_->sqlvar+columnIndex)->sqldata;
}

//CJL-IB6 support for new types
inline
IB_SINT64
IB_ResultSet::getInt64 (const IB_SSHORT16 columnIndex) const
{
	IB_Types::typeCheck (IB_Types::NUMERIC_INT64_TYPE, sqlda_->sqlvar+columnIndex);

	return *(IB_SINT64*) (sqlda_->sqlvar+columnIndex)->sqldata;
}

inline
IB_SLONG32 
IB_ResultSet::getSQLDate (const IB_SSHORT16 columnIndex) const
{
  IB_Types::typeCheck (IB_Types::SQL_DATE_TYPE, sqlda_->sqlvar+columnIndex);

  return *(IB_SLONG32*) (sqlda_->sqlvar+columnIndex)->sqldata;
}

inline
IB_ULONG32 
IB_ResultSet::getTime (const IB_SSHORT16 columnIndex) const
{
  IB_Types::typeCheck (IB_Types::TIME_TYPE, sqlda_->sqlvar+columnIndex);

  return *(IB_ULONG32*) (sqlda_->sqlvar+columnIndex)->sqldata;
}
// CJL-IB6 end change

inline
IB_SSHORT16
IB_ResultSet::getMaxFieldSize () const
{
  return maxFieldSize_;
}

inline
void
IB_ResultSet::setMaxFieldSize (const IB_SSHORT16 maxFieldSize)
{
  maxFieldSize_ = (IB_SSHORT16) maxFieldSize;
}

inline
IB_SSHORT16
IB_ResultSet::getColumnCount () const
{
  return sqlda_->sqld;
}

inline
IB_BOOLEAN 
IB_ResultSet::isColumnNullable (const IB_SSHORT16 columnIndex) const
{
  validateIndex (columnIndex);
  return IB_Types::isTypeTokenNullable ((sqlda_->sqlvar+columnIndex)->sqltype);
}

inline
IB_Types::IBType 
IB_ResultSet::getColumnType (const IB_SSHORT16 columnIndex) const
{
  validateIndex (columnIndex);
  return IB_Types::getIBType (sqlda_->sqlvar+columnIndex);
}

#ifdef IB_USER_API
inline
IB_LDString 
IB_ResultSet::getColumnTypeName (const IB_SSHORT16 columnIndex) const
{
  validateIndex (columnIndex);
  return IB_Types::getIBTypeName (sqlda_->sqlvar+columnIndex);
}
#endif

inline
IB_LDString
IB_ResultSet::getColumnLabel (const IB_SSHORT16 columnIndex) const 
{
  validateIndex (columnIndex);
  return IB_LDString ((sqlda_->sqlvar+columnIndex)->aliasname_length,
		      (sqlda_->sqlvar+columnIndex)->aliasname);
}

inline
IB_LDString 
IB_ResultSet::getColumnName (const IB_SSHORT16 columnIndex) const
{
  validateIndex (columnIndex);
  return IB_LDString ((sqlda_->sqlvar+columnIndex)->sqlname_length,
		      (sqlda_->sqlvar+columnIndex)->sqlname);
}

inline
IB_SSHORT16 
IB_ResultSet::getColumnPrecision (const IB_SSHORT16 columnIndex) const
{
  validateIndex (columnIndex);
  return IB_Types::getPrecision (sqlda_->sqlvar+columnIndex);
}

inline
IB_SSHORT16 
IB_ResultSet::getColumnScale (const IB_SSHORT16 columnIndex) const
{
  validateIndex (columnIndex);
  return IB_Types::getScale (sqlda_->sqlvar+columnIndex);
}

inline
IB_SSHORT16 
IB_ResultSet::getColumnCharSet (const IB_SSHORT16 columnIndex) const
{
  validateIndex (columnIndex);
  // !!! check for blob type, get char set from blob descriptor
  return IB_Types::getSubType (sqlda_->sqlvar+columnIndex);
}

inline
IB_SSHORT16 
IB_ResultSet::getColumnCharLength (const IB_SSHORT16 columnIndex) const
{
  validateIndex (columnIndex);
  // !!! check for blob type
  return charLengths_[columnIndex];
}

inline
IB_LDString 
IB_ResultSet::getColumnTableName (const IB_SSHORT16 columnIndex) const
{
  validateIndex (columnIndex);
  return IB_LDString ((sqlda_->sqlvar+columnIndex)->relname_length,
		      (sqlda_->sqlvar+columnIndex)->relname);
}

inline
IB_BOOLEAN 
IB_ResultSet::isColumnWritable (const IB_SSHORT16 columnIndex) const
{
  validateIndex (columnIndex);
  // Not yet implemented.
  // !!! Do a system security table query here,
  throw new IB_SQLException (IB_SQLException::bugCheck__0__,
			     10024,
			     IB_SQLException::bugCheckException__);
  return 0;
}

inline
void 
IB_ResultSet::setCatalogFunction (const int catalogFunction)
{
  catalogFunction_ = catalogFunction;
}

inline
int 
IB_ResultSet::getCatalogFunction ()
{
  return catalogFunction_;
}

#endif
